---
layout: post
date: 2016-03-09
author: 山庄来客
update: 2016-07-16
categories: wifi wpa_supplicant
---
<div id="content">
<h1 class="title">wpa_supplicant学习要点记录</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1"><code>wpa_supplicant</code> 基本架构分析</a>
<ul>
<li><a href="#sec-1-1">模块结构图</a></li>
<li><a href="#sec-1-2">全局数据结构</a>
<ul>
<li><a href="#sec-1-2-1"><code>struct wpa_supplicant</code></a></li>
<li><a href="#sec-1-2-2"><code>struct wpa_global</code></a></li>
<li><a href="#sec-1-2-3"><code>struct wpa_radio</code></a></li>
<li><a href="#sec-1-2-4"><code>struct wpa_radio_work</code></a></li>
<li><a href="#sec-1-2-5"><code>struct nl80211_global</code></a></li>
<li><a href="#sec-1-2-6"><code>struct wpa_driver_nl80211_data</code></a></li>
<li><a href="#sec-1-2-7"><code>struct i802_bss</code></a></li>
<li><a href="#sec-1-2-8"><code>struct nl80211_global</code></a></li>
</ul>
</li>
<li><a href="#sec-1-3"><code>wpa_supplicant</code> 初始化分析</a>
<ul>
<li><a href="#sec-1-3-1"><code>wpa_supplicant</code> 初始化执行过程</a></li>
<li><a href="#sec-1-3-2"><code>wpa_supplicant_init</code> 函数执行过程</a></li>
<li><a href="#sec-1-3-3"><code>wpa_supplicant_add_iface</code> 函数执行过程</a></li>
</ul>
</li>
<li><a href="#sec-1-4">event loop</a>
<ul>
<li><a href="#sec-1-4-1">eloop data structure</a></li>
<li><a href="#sec-1-4-2"><code>eloop_init()</code></a></li>
<li><a href="#sec-1-4-3">注册事件处理函数</a></li>
<li><a href="#sec-1-4-4">start event loop</a></li>
<li><a href="#sec-1-4-5">其他一些 <code>eloop_*</code> 函数速速览</a></li>
</ul>
</li>
<li><a href="#sec-1-5">ctrl interface</a>
<ul>
<li><a href="#sec-1-5-1">概述</a></li>
<li><a href="#sec-1-5-2">主要API</a></li>
<li><a href="#sec-1-5-3">CMMAND</a></li>
</ul>
</li>
<li><a href="#sec-1-6">configuration</a></li>
<li><a href="#sec-1-7">Cryptographic functions</a></li>
<li><a href="#sec-1-8">driver interface</a>
<ul>
<li><a href="#sec-1-8-1">基本机制研究</a></li>
<li><a href="#sec-1-8-2">配置加密方法（TKIP/CCMP）</a></li>
<li><a href="#sec-1-8-3">漫游和扫描支持</a></li>
<li><a href="#sec-1-8-4">产生WPA IE</a></li>
<li><a href="#sec-1-8-5">rfkill</a></li>
</ul>
</li>
<li><a href="#sec-1-9">l2 packets</a>
<ul>
<li><a href="#sec-1-9-1">链路层套接字 <code>PF_PACKET</code></a></li>
<li><a href="#sec-1-9-2"><code>wpa_supplicant</code> 中 <code>l2_packet</code> 的初始化</a></li>
<li><a href="#sec-1-9-3">管理帧发送和接收</a></li>
</ul>
</li>
<li><a href="#sec-1-10"><code>hostapd_setup_bss</code></a></li>
<li><a href="#sec-1-11">State Machine</a>
<ul>
<li><a href="#sec-1-11-1">状态机的定义</a></li>
<li><a href="#sec-1-11-2">WPA/WPA2</a></li>
<li><a href="#sec-1-11-3">EAPOL</a></li>
<li><a href="#sec-1-11-4">EAP</a></li>
<li><a href="#sec-1-11-5">wpa statemachine状态变化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-2"><code>wpa_supplicant</code> 功能模块分析</a>
<ul>
<li><a href="#sec-2-1">P2P</a>
<ul>
<li><a href="#sec-2-1-1">数据结构分析与初始化流程</a></li>
<li><a href="#sec-2-1-2">基本连接流程</a></li>
<li><a href="#sec-2-1-3">p2p管理</a></li>
<li><a href="#sec-2-1-4">Go创建</a></li>
<li><a href="#sec-2-1-5">socket control interface</a></li>
<li><a href="#sec-2-1-6">nl80211 (p2p)</a></li>
<li><a href="#sec-2-1-7">问题调试</a></li>
</ul>
</li>
<li><a href="#sec-2-2">bgscan (roaming) IAPP(Inter Access Point Protocol)</a></li>
<li><a href="#sec-2-3">WPS</a>
<ul>
<li><a href="#sec-2-3-1">Enrollee</a></li>
<li><a href="#sec-2-3-2">Registar</a></li>
</ul>
</li>
<li><a href="#sec-2-4">SME</a></li>
<li><a href="#sec-2-5">SoftAp</a>
<ul>
<li><a href="#sec-2-5-1">数据结构</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3"><code>wpa_supplicant</code> 代码修改</a>
<ul>
<li><a href="#sec-3-1">add a conf parameter to start a GO as HT40 if allowed</a></li>
<li><a href="#sec-3-2">add 165和169信道支持</a></li>
<li><a href="#sec-3-3">P2P: Clear the discovery state incase of deffered GO Neg response</a></li>
<li><a href="#sec-3-4">Android: P2P: Fix restriction of GO channels on A-band</a></li>
</ul>
</li>
<li><a href="#sec-4">常用代码片断</a>
<ul>
<li><a href="#sec-4-1">遍历当前的接口</a></li>
<li><a href="#sec-4-2">遍历接口上存在的SSID</a></li>
<li><a href="#sec-4-3">遍历当前的接口(方法2)</a></li>
<li><a href="#sec-4-4">遍历hostapd上的bss</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><code>wpa_supplicant</code> 基本架构分析<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup> <sup>, </sup><sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup></h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">模块结构图</h3>
<div class="outline-text-3" id="text-1-1">

<div class="figure">
<p><img src="/images/2015/2015121506.png" alt="2015121506.png" />
</p>
<p><span class="figure-number">Figure 1:</span> <code>wpa_supplicant modules</code></p>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">全局数据结构</h3>
<div class="outline-text-3" id="text-1-2">
</div><div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1"><code>struct wpa_supplicant</code></h4>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2"><code>struct wpa_global</code></h4>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3"><code>struct wpa_radio</code></h4>
<div class="outline-text-4" id="text-1-2-3">
<div class="org-src-container">

<pre class="src src-c">/**
 * struct wpa_radio - Internal data for per-radio information
 *
 * This structure is used to share data about configured interfaces
 * (struct wpa_supplicant) that share the same physical radio, e.g., to allow
 * better coordination of offchannel operations.
 */
struct wpa_radio {
        char name[16]; /* from driver_ops get_radio_name() or empty if not
                        * available */
        unsigned int external_scan_running:1;
        unsigned int num_active_works;
        struct dl_list ifaces; /* struct wpa_supplicant::radio_list entries */
        struct dl_list work; /* struct wpa_radio_work::list entries */
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4"><code>struct wpa_radio_work</code></h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
Radio work item, 数据结构定义如下：
</p>
<div class="org-src-container">

<pre class="src src-c">/**
 * struct wpa_radio_work - Radio work item
 */
struct wpa_radio_work {
        struct dl_list list;
        unsigned int freq; /* known frequency (MHz) or 0 for multiple/unknown */
        const char *type;
        struct wpa_supplicant *wpa_s;
        void (*cb)(struct wpa_radio_work *work, int deinit);
        void *ctx;  //pointer to struct wpa_connect_work  ==&gt;Yajun
        unsigned int started:1;
        struct os_reltime time;
        unsigned int bands;
};
</pre>
</div>
<p>
相关的函数接口
</p>
<ol class="org-ol">
<li><code>radio_add_work</code>
</li>
<li><code>radio_work_done</code>
</li>
<li><code>radio_remove_works</code>
</li>
<li><code>radio_work_check_next</code>
</li>
<li><code>radio_work_pending</code>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5"><code>struct nl80211_global</code></h4>
<div class="outline-text-4" id="text-1-2-5">
<div class="org-src-container">

<pre class="src src-c">struct nl80211_global {
        struct dl_list interfaces;
        int if_add_ifindex;
        u64 if_add_wdevid;
        int if_add_wdevid_set;
        struct netlink_data *netlink;
        struct nl_cb *nl_cb;
        struct nl_handle *nl;
        int nl80211_id;   //family id for nl802.11
        int ioctl_sock; /* socket for ioctl() use */

        struct nl_handle *nl_event;
};
</pre>
</div>
<p>
其中 <code>nl_event</code> 接收Driver上报的事件。
<code>nl</code> 用于 <code>wpa_supplicant</code> 向Driver下一些 netlink 命令。
</p>
</div>
</div>
<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6"><code>struct wpa_driver_nl80211_data</code></h4>
</div>
<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7"><code>struct i802_bss</code></h4>
<div class="outline-text-4" id="text-1-2-7">
<div class="org-src-container">

<pre class="src src-c">struct i802_bss {
        struct wpa_driver_nl80211_data *drv;
        struct i802_bss *next;
        int ifindex;
        u64 wdev_id;
        char ifname[IFNAMSIZ + 1];
        char brname[IFNAMSIZ];
        unsigned int beacon_set:1;
        unsigned int added_if_into_bridge:1;
        unsigned int added_bridge:1;
        unsigned int in_deinit:1;
        unsigned int wdev_id_set:1;

        u8 addr[ETH_ALEN];

        int freq;
        int if_dynamic;

        void *ctx;
        struct nl_handle *nl_preq, *nl_mgmt;
        struct nl_cb *nl_cb;

        struct nl80211_wiphy_data *wiphy_data;
        struct dl_list wiphy_list;
};
</pre>
</div>
<p>
<code>struct nl_mgmt</code> 注册管理帧，如Action帧. 在设置设备模式
<code>wpa_driver_nl80211_set_mode</code> 的时候，
<code>wpa_supplicant</code> 会向Driver注册一些Action帧。
</p>
</div>
</div>
<div id="outline-container-sec-1-2-8" class="outline-4">
<h4 id="sec-1-2-8"><code>struct nl80211_global</code></h4>
<div class="outline-text-4" id="text-1-2-8">
<div class="org-src-container">

<pre class="src src-c">struct nl80211_global {
        struct dl_list interfaces;
        int if_add_ifindex;
        u64 if_add_wdevid;
        int if_add_wdevid_set;
        struct netlink_data *netlink;
        struct nl_cb *nl_cb;
        struct nl_handle *nl;
        int nl80211_id;
        int ioctl_sock; /* socket for ioctl() use */

  //netlink socket
  //接收Driver回报的一些事件(广播事件)，如scan, mlme, regulatory,vendor
        struct nl_handle *nl_event;
};
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><code>wpa_supplicant</code> 初始化分析</h3>
<div class="outline-text-3" id="text-1-3">
</div><div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><code>wpa_supplicant</code> 初始化执行过程</h4>
<div class="outline-text-4" id="text-1-3-1">

<div class="figure">
<p><img src="/images/2015/2015123004.png" alt="2015123004.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><code>wpa_supplicant_init</code> 函数执行过程</h4>
<div class="outline-text-4" id="text-1-3-2">

<div class="figure">
<p><img src="/images/2016/2016011410.png" alt="2016011410.png" />
</p>
</div>

<p>
接下来看 <code>wpa_supplicant_global_ctrl_iface_init</code> 的执行过程。
</p>


<div class="figure">
<p><img src="/images/2015/2015123002.png" alt="2015123002.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3"><code>wpa_supplicant_add_iface</code> 函数执行过程</h4>
<div class="outline-text-4" id="text-1-3-3">

<div class="figure">
<p><img src="/images/2015/2015123003.png" alt="2015123003.png" />
</p>
</div>
</div>

<ul class="org-ul"><li><a id="sec-1-3-3-1" name="sec-1-3-3-1"></a><code>wpa_supplicant_init_iface</code><br  /><div class="outline-text-5" id="text-1-3-3-1">
<p>
初始化网络接口， 读取配置文件，初始化EAPOL状态机，初始化Driver，
初始化 wpa状态机等等。
</p>


<div class="figure">
<p><img src="/images/2016/2016010501.png" alt="2016010501.png" />
</p>
</div>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">event loop</h3>
<div class="outline-text-3" id="text-1-4">
</div><div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">eloop data structure</h4>
<div class="outline-text-4" id="text-1-4-1">
<p>
定义了事件循环接口，支持处理注册的超时事件（例如：过多少秒后，
执行某个操作）， socket事件以及信号事件等。
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1-1" name="sec-1-4-1-1"></a>eloop相关数据结构的关系<br  /><div class="outline-text-5" id="text-1-4-1-1">

<div class="figure">
<p><img src="/images/2015/2015122901.png" alt="2015122901.png" />
</p>
<p><span class="figure-number">Figure 7:</span> struct eloop<sub>data</sub></p>
</div>

<p>
socket主要有读、写和异常等三种。 <code>struct eloop_sock_table</code> 是
一个表结构，维护了当前所有的socket，针对读、写和异常分别对应一个
表结构。
</p>
</div>
</li>
<li><a id="sec-1-4-1-2" name="sec-1-4-1-2"></a><code>eloop_sock</code><br  /><ul class="org-ul"><li><a id="sec-1-4-1-2-1" name="sec-1-4-1-2-1"></a>eloop sock event type<br  /><div class="outline-text-6" id="text-1-4-1-2-1">
<p>
<code>eloop_register_sock()</code> 注册的socket事件类型。 
</p>

<div class="org-src-container">

<pre class="src src-c">typedef enum {
        EVENT_TYPE_READ = 0,
        EVENT_TYPE_WRITE,
        EVENT_TYPE_EXCEPTION
} eloop_event_type;
</pre>
</div>

<p>
<code>event_sock</code> 主要的关注的事件是读、写和异常。
</p>
</div>
</li>

<li><a id="sec-1-4-1-2-2" name="sec-1-4-1-2-2"></a>eloop socket event callback type<br  /><div class="outline-text-6" id="text-1-4-1-2-2">
<div class="org-src-container">

<pre class="src src-c">/**
 * eloop_sock_handler - eloop socket event callback type
 */
typedef void (*eloop_sock_handler)(int sock, void *eloop_ctx, void *sock_ctx);
</pre>
</div>
</div>
</li></ul>
</li>

<li><a id="sec-1-4-1-3" name="sec-1-4-1-3"></a>eloop event<br  /><div class="outline-text-5" id="text-1-4-1-3">
<p>
通用事件
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1-3-1" name="sec-1-4-1-3-1"></a>回调函数<br  /><div class="outline-text-6" id="text-1-4-1-3-1">
<div class="org-src-container">

<pre class="src src-c">/**
 ,* eloop_event_handler - eloop generic event callback type
 ,*/
typedef void (*eloop_event_handler)(void *eloop_data, void *user_ctx);
</pre>
</div>
</div>
</li></ul>
</li>

<li><a id="sec-1-4-1-4" name="sec-1-4-1-4"></a>eloop timeout<br  /><div class="outline-text-5" id="text-1-4-1-4">
<p>
处理超时事件 
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1-4-1" name="sec-1-4-1-4-1"></a>回调函数<br  /><div class="outline-text-6" id="text-1-4-1-4-1">
<div class="org-src-container">

<pre class="src src-c">/**
 ,* eloop_timeout_handler - eloop timeout event callback type
 ,*/
typedef void (*eloop_timeout_handler)(void *eloop_data, void *user_ctx);
</pre>
</div>
</div>
</li></ul>
</li>

<li><a id="sec-1-4-1-5" name="sec-1-4-1-5"></a>eloop signal<br  /><div class="outline-text-5" id="text-1-4-1-5">
<p>
系统信号处理
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-4-1-5-1" name="sec-1-4-1-5-1"></a>回调函数<br  /><div class="outline-text-6" id="text-1-4-1-5-1">
<div class="org-src-container">

<pre class="src src-c">/**
 ,* eloop_signal_handler - eloop signal event callback type
 ,*/
typedef void (*eloop_signal_handler)(int sig, void *signal_ctx);
</pre>
</div>
</div>
</li></ul>
</li></ul>
</div>
<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2"><code>eloop_init()</code></h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
初始化一个全局的event loop data。 在其他 <code>eloop_*</code> 前调用。
</p>
</div>
</div>

<div id="outline-container-sec-1-4-3" class="outline-4">
<h4 id="sec-1-4-3">注册事件处理函数</h4>
<div class="outline-text-4" id="text-1-4-3">
<ol class="org-ol">
<li>register socket读、写，异常等事件

<div class="org-src-container">

<pre class="src src-c">/*
 * Register a read socket notifier for the given file descriptor.
 */
int eloop_register_read_sock(int sock, eloop_sock_handler handler,
                             void *eloop_data, void *user_data);
/*
 *  Register an event notifier for the given socket's file descriptor.
 */
int eloop_register_sock(int sock, eloop_event_type type,
                        eloop_sock_handler handler,
                        void *eloop_data, void *user_data);
</pre>
</div>
</li>

<li>注册系统相关事件

<div class="org-src-container">

<pre class="src src-c">int eloop_register_event(void *event, size_t event_size,
                         eloop_event_handler handler,
                         void *eloop_data, void *user_data);
</pre>
</div>
</li>

<li>注册超时处理函数

<p>
该函数将会在secs秒后执行。 
</p>
<div class="org-src-container">

<pre class="src src-c">int eloop_register_timeout(unsigned int secs, unsigned int usecs,
                           eloop_timeout_handler handler,
                           void *eloop_data, void *user_data);
</pre>
</div>
</li>

<li>注册信号处理函数

<div class="org-src-container">

<pre class="src src-c">int eloop_register_signal(int sig, eloop_signal_handler handler,
                          void *user_data);

/*
 *  registers handlers for SIGINT and SIGTERM.
 */
int eloop_register_signal_terminate(eloop_signal_handler handler,
                                    void *user_data);
</pre>
</div>
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-1-4-4" class="outline-4">
<h4 id="sec-1-4-4">start event loop</h4>
<div class="outline-text-4" id="text-1-4-4">

<div class="figure">
<p><img src="/images/2015/2015123001.png" alt="2015123001.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-4-5" class="outline-4">
<h4 id="sec-1-4-5">其他一些 <code>eloop_*</code> 函数速速览</h4>
<div class="outline-text-4" id="text-1-4-5">
<div class="org-src-container">

<pre class="src src-c">/*
 * 监听发生在某个socket的读事件
 */
void eloop_wait_for_read_sock(int sock)

/*
 * 注册一个系统信号处理函数
 */
int eloop_register_signal(int sig, eloop_signal_handler handler,
                          void *user_data)

/*
 * 处理目前已经触发的系统信号
 */
static void eloop_process_pending_signals(void)

/*
 * 处理某个触发的系统信号
 */
static void eloop_handle_signal(int sig)

/*
 * 检查一个timeout处理函数是否已经注册
 */
int eloop_is_timeout_registered(eloop_timeout_handler handler,
                                void *eloop_data, void *user_data)

/*
 *取消一个已经注册的timeout处理函数
 */
int eloop_cancel_timeout_one(eloop_timeout_handler handler,
                             void *eloop_data, void *user_data,
                             struct os_time *remaining)

/*
 * 取消一个或多个已经注册的timeout处理函数
 */
int eloop_cancel_timeout(eloop_timeout_handler handler,
                         void *eloop_data, void *user_data)

/*
 * 从timeout链表中删除一个eloop_timeout项
 */
static void eloop_remove_timeout(struct eloop_timeout *timeout)

/*
 * 注册一个eloop_timeout项，按超时时间的大小，从小
 * 到大的顺序排列
 */
int eloop_register_timeout(unsigned int secs, unsigned int usecs,
                           eloop_timeout_handler handler,
                           void *eloop_data, void *user_data)
/*
 * 注册一个Socket监听对象，添加到相应的监控表中
 * (read, write, exception)
 */
int eloop_register_sock(int sock, eloop_event_type type,
                        eloop_sock_handler handler,
                        void *eloop_data, void *user_data)

/*
 * 注册一个Socket监听对象，监测它的读事件
 */
int eloop_register_read_sock(int sock, eloop_sock_handler handler,
                             void *eloop_data, void *user_data)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">ctrl interface</h3>
<div class="outline-text-3" id="text-1-5">
</div><div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">概述</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
<code>wpa_supplicnat</code> 提供了控制接口，可以允许通过外部程序获得
<code>wpa_supplicant</code> 的状态信息，并对其进行管理。相应文件说明如下：
</p>
<ul class="org-ul">
<li><code>ctrl_iface.c and ctrl_iface.h</code>  <code>wpa_supplicant-side</code> of the
control interface
</li>
<li><code>ctrl_iface_unix.c</code> UNIX domain <code>sockets-based</code> control interface
backend
</li>
<li><code>ctrl_iface_udp.c</code> UDP <code>sockets-based</code> control interface backend
</li>
<li><code>ctrl_iface_named_pipe.c</code> Windows <code>named pipes-based</code> control
interface backend
</li>
<li><code>wpa_ctrl.c and wpa_ctrl.h</code> Library functions for external
programs to provide access to the wpa<sub>supplicant</sub> control
interface
</li>
</ul>
<p>
外部程序可以通过 <code>ctrl_iface</code> 向 <code>wpa_supplicant</code> 主动发送命令，也
可以被动接收 <code>wpa_supplicant</code> 主动发送过来的一些事件报告。 在
<code>wpa_supplicant_ctrl_iface_init</code> 中调用了 <code>wpa_msg_register_cb</code> 注册了
callback函数 <code>wpa_supplicant_ctrl_iface_msg_cb</code> ， 在该函数中，会主动
将supplicant中发生的一些关键事件发送给上层监听的对端，以便他们能够
了解 <code>wpa_supplicant</code> 的状态变化 。在 <code>wpa_msg</code> , <code>wpa_msg_ctrl</code> ,
<code>wpa_msg_global</code> , <code>wpa_msg_no_global</code> , 中会自动调用该回调函数 。
</p>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">主要API</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
主要有两种类型的通信： 命令与底层主动发送的事件消息。
命令由请求和响应组成。 如果要监听底层主动发上来的消息，必须注册监
听器。
</p>
<ol class="org-ol">
<li>打开与 <code>wpa_supplicant</code> 的一个连接   
<div class="org-src-container">

<pre class="src src-c">struct wpa_ctrl * wpa_ctrl_open(const char *ctrl_path);
</pre>
</div>
</li>

<li>发送命令
<div class="org-src-container">

<pre class="src src-c">int wpa_ctrl_request(struct wpa_ctrl *ctrl, const char *cmd,
                     size_t cmd_len, char *reply, size_t *reply_len,
                     void (*msg_cb)(char *msg, size_t len));
</pre>
</div>
</li>

<li>注册控制接口的事件监听器  
<div class="org-src-container">

<pre class="src src-c">int wpa_ctrl_attach(struct wpa_ctrl *ctrl);
</pre>
</div>
</li>

<li>接收来看控制接口的消息  
<div class="org-src-container">

<pre class="src src-c">int wpa_ctrl_recv(struct wpa_ctrl *ctrl, char *reply, size_t *reply_len);
</pre>
</div>
</li>

<li>检查是否有未决的事件消息  
<div class="org-src-container">

<pre class="src src-c">int wpa_ctrl_pending(struct wpa_ctrl *ctrl);
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">CMMAND</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>PING
</li>
<li>MIB
</li>
<li>STATUS
</li>
<li><code>STATUS-verbose</code>
</li>
<li>PMKSA
</li>
<li>SET &lt;variable&gt; &lt;valus&gt;
</li>
<li>LOGON
</li>
<li>LOGOFF
</li>
<li>REASSOCIATE
</li>
<li>RECONNECT
</li>
<li>PREAUTH &lt;BSSID&gt;
</li>
<li>ATTACH
</li>
<li>DETACH
</li>
<li>LEVEL &lt;debug level&gt;
</li>
<li>RECONFIGURE
</li>
<li>TERMINATE
</li>
<li>BSSID &lt;network id&gt; &lt;BSSID&gt;
</li>
<li><code>LIST_NETWORKS</code>
</li>
<li>DISCONNECT
</li>
<li>SCAN
SCAN流程分析
<code>wpa_supplicant_event</code> &#x2013;&gt; <code>EVENT_SCAN_RESULTS</code> &#x2013;&gt;
<code>wpa_supplicant_event_scan_results</code>
每次扫描结束会，会调用 <code>wpas_select_network_from_last_scan</code> 来
选择一个网络进行连接。
</li>
<li><code>SCAN_RESULTS</code>
</li>
<li>BSS
</li>
<li><code>SELECT_NETWORK</code> &lt;network id&gt;
</li>
<li><code>ENABLE_NETWORK</code> &lt;network id&gt;
</li>
<li><code>DISABLE_NETWORK</code> &lt;network id&gt;
</li>
<li><code>ADD_NETWORK</code>
</li>
<li><code>REMOVE_NETWORK</code> &lt;network id&gt;
</li>
<li><code>SET_NETWORK</code> &lt;network id&gt; &lt;variable&gt; &lt;value&gt;
</li>
<li><code>GET_NETWORK</code> &lt;network id&gt; &lt;variable&gt;
</li>
<li><code>SAVE_CONFIG</code>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">configuration</h3>
<div class="outline-text-3" id="text-1-6">
<p>
主要数据结构：
</p>
<div class="org-src-container">

<pre class="src src-c">struct wpa_config{

};
</pre>
</div>
<p>
函数 <code>wpa_config_alloc_empty(...)</code> 定义了所有成员的默认值，一些重要配置
项如下所示：
</p>
<ul class="org-ul">
<li><code>update_config</code> 
     是否允许 <code>wpa_supplicant</code> 覆盖(更新)配置文件（当配置文件发生变化时）。
</li>
<li><code>ctrl_interface</code> 
这是一个全局配置，指定了该参数后， <code>wpa_supplicant</code> 会打开一个控
制接口，外部程序可以通过此控制接口来管理 <code>wpa_supplicant</code> 。 字符
串的含义取决于使用的控制接口的机制。 但是，有一点，只要配置了该参
数，就表明启用了控制接口机制。 
对于 <code>UNIX domain sockets</code> ， 这是为 <code>Unix domain socket</code> 创建的
一个目录，用于监听来自外部程序的请求。 新创建的socket文件会在这个
目录中，如对于接口名称为 <code>wlan0</code> 的接口，会在 <code>ctrl_interface</code> 指
定的目录下创建一个socket文件： <code>wlan0</code> 。 
通过修改 <code>wpa_ctrl</code> 指定的目录的权限来控制访问 <code>wpa_supplicant</code>
， 默认情况下， <code>wpa_supplicant</code> 默认配置为使用GID为0， 即root权
限。 例如：
<div class="org-src-container">

<pre class="src src-sh"># DIR=/var/run/wpa_supplicant GROUP=wheel
# DIR=/var/run/wpa_supplicant GROUP=0
# (group can be either group name or gid)
</pre>
</div>

<p>
对于 UDP连接（Windows默认行为），该值会被忽略。 该值只是用来选择
将被创建的控制接口，该值可被设置为 <code>udp</code> 。( <code>control_interface</code>
udp) 
</p>

<p>
对于Windows的命名管道，该值用于设置访问控制接口的安全描述符。如
</p>
<pre class="example">
ctrl_interface=SDDL=D:= 。
</pre>
</li>
<li><code>eapol_version</code> 
设置 <code>IEEE 802.1X/EAPOL</code> 的版本， <code>wpa_supplicant</code> 是基于 <code>IEEE
     802.1X-2004 EAPOL version 2</code>  实现的，  但是为了兼容不支持
version 2的AP，该值默认为设置为1. 当使用MACSec时，该值应该设置
为3，在 <code>IEEE Std 802.1X-2010</code> 中有定义。
</li>
<li><code>ap_scan</code> 
默认情况下， <code>wpa_supplicant</code> 会请求驱动执行AP扫描，然后使用扫描
结果来选择一个合适的AP。另一种选择就是驱动负责AP扫描并选择一个AP
来关联， <code>wpa_supplicant</code> 只是基于驱动给出的关联信息去处理 EAPOL
帧。 有如下一些取值：  

<p>
1: <code>wpa_supplicant</code> initiates scanning and AP selection; if no APs
matching to  the currently enabled networks are found, a new
network (IBSS or AP mode  operation) may be initialized (if
configured) (default)
</p>

<p>
0: driver takes care of scanning, AP selection, and IEEE 802.11
association parameters; 
</p>

<p>
2: like 0, but associate with APs using security policy and SSID
(but not BSSID);在这种模式下，驱动会一个一个地尝试关联配置文件中
指定的网络，直到关联成功。另外，每个网络必须显式地配置安全策略。
</p>

<p>
对于使用 <code>nl80211</code> 驱动接口，一般选择 <code>ap_scan=1</code> ， 在这种模式
下，会先逐一扫描配置文件中的网络，如果没有合适的网络，会创建一个IBSS或
AP模式下的网络 。当使用IBSS或AP模式，使用 <code>ap_scan=2</code> 可以强制立
即创建新的网络，而不管扫描结果为何。
</p>
</li>
<li><code>passive_scan</code> 
     是否强制被动扫描。

<p>
0:  Do normal scans (allow active scans) (default)
</p>

<p>
1:  Do passive scans.
</p>

<p>
如果开启被动扫描，则会降低扫描设备的速度，且会导致有些AP扫不到，
如隐藏SSID的AP。
</p>
</li>
<li><code>user_mpm</code> 
默认情况下， <code>wpa_supplicnat</code> 会为一个Open Mesh实现MPM(Mesh
Peering Manager)，如果驱动实现了MPM，可以设置些值为0. 

<p>
0: MPM lives in the driver
</p>

<p>
1: wpa<sub>supplicant</sub> provides an MPM which handles peering (default)
</p>
</li>
<li><code>max_peer_links</code> 
Maximum number of mesh peering currently maintained by the STA.
Maximum number of peer links (0-255; default: 99)
</li>
<li><code>mesh_max_inactivity</code> 
This timeout value is used in mesh STA to clean up inactive
stations.
Timeout in seconds to detect STA inactivity (default: 300
seconds)
</li>
<li><code>cert_in_cb</code> 
This controls whether peer certificates for authentication server
and its certificate chain are included in EAP peer certificate
events.
This is enabled by default.
</li>
<li><code>fast_reauth</code> 
快速重新认证。默认情况下，对于所有支持的EAP方法，快速重新认证是开
启的。
</li>
<li><code>opensc_engine_path</code> 
     OpenSSL Engine support, 默认情况下，没有加载任何Engine.
</li>
<li><code>openssl_ciphers</code> 
     OpenSSL cipher string
</li>
<li><code>load_dynamic_eap</code>
Dynamic EAP methods. 当EAP方法是编译成单独的so文件时，需要配置该
项。默认情况下，EAP方法是静态编译到 <code>wpa_supplicant</code> 。
</li>
<li><code>driver_param</code>
     驱动接口参数, 在函数  <code>nl80211_set_param</code> 中设置。
<pre class="example">
driver_param=use_p2p_group_interface=1
</pre>
<p>
这个参数主要是针对P2P设置的，是否支持 p2p concurrent
operation. 每次p2p 协商成功后，会创建一个group interface. 通过这
个接口，来处理p2p相关的管理帧 ，也可以处理非p2p的管理帧，如关联请
求（GC与GO关联时的交互帧）
</p>
</li>
<li><code>country</code>
     国家码
</li>
<li><code>dot11RSNAConfigPMKLifetime</code>
     PMKSA最大存活时间，默认是43200秒.
</li>
<li><code>dot11RSNAConfigPMKReauthThreshold</code> 
     重新认证的阀值(PMKSA值的百分比), 默认是70.
</li>
<li><code>dot11RSNAConfigSATimeout</code> 
     安全关联的超时，默认是60秒。
</li>
<li><code>uuid</code> 
     Universally Unique IDentifier, 如果没有配置，会根据MAC地址来产生。
</li>
<li><code>device_name</code> 
     设备名，字符串。
</li>
<li><code>manufacturer</code>
     设备生产商， 字符串。
</li>
<li><code>model_name</code>
     设备模式。
</li>
<li><code>model_number</code> 
     模式编号。
</li>
<li><code>serial_number</code>
     序列号。
</li>
<li><code>device_type</code>
     主设备类型，格式：&lt;categ&gt;-&lt;OUI&gt;-&lt;subcateg&gt;
</li>
<li><code>os_version</code>
     操作系统版本号
</li>
<li><code>config_methods</code>
     WPS支持的方法。
</li>
<li><code>wps_cred_processing</code>

<p>
0: process received credentials internally (default)
</p>

<p>
1: do not process received credentials; just pass them over
 <code>ctrl_iface</code> to external program(s)
</p>

<p>
2: process received credentials internally and pass them over
ctrl<sub>iface</sub> to external program(s)
</p>
</li>
<li><code>wps_vendor_ext_m1</code> 
     Vendor attribute in WPS M1
</li>
<li><code>wps_priority</code>
     Priority for the networks added through WPS
</li>
<li><code>bss_max_count</code>
     Maximum number of BSS entries to keep in memory
</li>
<li><code>autoscan</code> 
     Automatic scan
</li>
<li><code>filter_ssids</code> 
过滤SSID
0： do not filter scan results (default)
1： only include configured SSIDs in scan results/BSS table
</li>
<li><code>ext_password_backend</code>
     Password (and passphrase, etc.) backend for external storage
</li>
<li><code>p2p_disabled</code>
     禁用P2P功能。
</li>
<li><code>p2p_go_max_inactivity</code>
     检测STA是否活跃的超时值，默认是300秒。
</li>
<li><code>p2p_passphrase_len</code>
     GO随机产生的密码的长度，默认是8.
</li>
<li><code>p2p_search_delay</code>
Extra delay between concurrent P2P search iterations
默认值为：500ms.
</li>
<li><code>dtim_period</code>
     efault value for DTIM period
</li>
<li><code>beacon_int</code>
     Default value for Beacon interval
</li>
<li><code>ap_vendor_elements</code>
Additional vendor specific elements for Beacon and Probe Response
frames
</li>
<li><code>ignore_old_scan_res</code>
     Ignore scan results older than request
</li>
<li><code>scan_cur_freq</code>
Whether to scan only the current frequency
0: Scan all available frequencies. (Default)
1: Scan current operating frequency if another VIF on the same
radio is already associated.
</li>
<li><code>mac_addr</code>

<p>
0 = use permanent MAC address
</p>

<p>
1 = use random MAC address for each ESS connection
</p>

<p>
2 = like 1, but maintain OUI (with local admin bit set)
</p>
</li>
<li><code>rand_addr_lifetime</code>
     随机MAC地址的存活时间，默认是60秒。
</li>
<li><code>preassoc_mac_addr</code>

<p>
MAC address policy for pre-association operations
</p>

<p>
0 = use permanent MAC address
</p>

<p>
1 = use random MAC address
</p>

<p>
2 = like 1, but maintain OUI (with local admin bit set)
</p>

<ul class="org-ul">
<li><code>config_ssid.h</code> Definition of per network configuration items
</li>
<li><code>config.h</code> Definition of the <code>wpa_supplicant</code> configuration
</li>
<li><code>config.c</code> Configuration parser and common functions
</li>
<li><code>config_file.c</code> Configuration backend for text files (e.g.,
<code>wpa_supplicant</code>.
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Cryptographic functions</h3>
<div class="outline-text-3" id="text-1-7">
<p>
重点看下如何调用这些函数进行加密的
</p>
</div>
</div>

<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">driver interface</h3>
<div class="outline-text-3" id="text-1-8">
<p>
一个新的驱动的注册主要是定义一个 <code>wpa_driver_ops</code> 结构体实例。 硬件
的部分代码会通过这个结构体提供的一些回调函数来控制驱动/无线网卡。 
</p>
</div>

<div id="outline-container-sec-1-8-1" class="outline-4">
<h4 id="sec-1-8-1">基本机制研究</h4>
<div class="outline-text-4" id="text-1-8-1">
</div><ul class="org-ul"><li><a id="sec-1-8-1-1" name="sec-1-8-1-1"></a>如何通过 <code>wpa_supplicant</code> 向Driver发送命令。<br  /><div class="outline-text-5" id="text-1-8-1-1">
<p>
这个流程很简单， <code>wap_supplicant</code> 是利用 <code>wpa_driver_ops</code> 注册
的回调函数，来向Driver下达命令， 这些回调函数实际会通过
netlink标准命令，将用户请求的命令传达到内核，并最终触发Driver
向硬件下达命令。
</p>
</div>
</li>

<li><a id="sec-1-8-1-2" name="sec-1-8-1-2"></a><code>wpa_supplicant</code> 如休接收到底层Driver发送过来的事件<br  /><div class="outline-text-5" id="text-1-8-1-2">

<div class="figure">
<p><img src="/images/2016/2016012001.png" alt="2016012001.png" />
</p>
</div>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-8-2" class="outline-4">
<h4 id="sec-1-8-2">配置加密方法（TKIP/CCMP）</h4>
<div class="outline-text-4" id="text-1-8-2">
<p>
如果是在Driver中实现的，必须提供一种配置的手段。
</p>
</div>
</div>

<div id="outline-container-sec-1-8-3" class="outline-4">
<h4 id="sec-1-8-3">漫游和扫描支持</h4>
</div>
<div id="outline-container-sec-1-8-4" class="outline-4">
<h4 id="sec-1-8-4">产生WPA IE</h4>
<div class="outline-text-4" id="text-1-8-4">
<p>
WPA IE是在Driver中产生的还是在 <code>wpa_supplicant</code> 中产生的？
</p>
</div>
</div>

<div id="outline-container-sec-1-8-5" class="outline-4">
<h4 id="sec-1-8-5">rfkill</h4>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">l2 packets</h3>
<div class="outline-text-3" id="text-1-9">
</div><div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">链路层套接字 <code>PF_PACKET</code></h4>
<div class="outline-text-4" id="text-1-9-1">
<p>
Packet套接字用于在MAC层上收发原始数据帧，这样就允许用户在用户空间
完成MAC之上各个层次的实现。
Packet套接字的定义方式与传送层的套接字定义类似，如下：
</p>
<div class="org-src-container">

<pre class="src src-c">packet_socket=socket(PF_PACKET,int socket_type,int protocol);
</pre>
</div>


<p>
其中 <code>socket_type</code> 有两种类型，一种为 <code>SOCK_RAW</code>,它是包含了MAC层头
部信息的原始分组，当然这种类型的套接字在发送的时候需要自己加上一个
MAC头部（其类型定义在 <code>linux&lt;/if_ether.h</code> 中，ethhdr），另一种是
<code>SOCK_DGRAM</code> 类型，它是已经进行了MAC层头部处理的，即收上的帧已经去
掉了头部，而发送时也无须用户添加头部字段。Protocol是指其送交的上层
的协议号，如IP为0x0800，当其为 <code>htons(ETH_P_ALL)</code> （其宏定义为0）
时表示收发所有的协议。创建好套接字后，就可以通过与UDP一样的
recvfrom与sendto函数进行数据的收发，其目的地址结构为 <code>sockaddr_ll</code>
，这与传送层的地址结构定义是不一样的，其长度为20字节（在TCP/IP的链
路层地址中使用了18字节），而传送层的地址结构长度为16字节。
</p>

<p>
Sockaddr<sub>ll结构如下：</sub>
</p>
<div class="org-src-container">

<pre class="src src-c">struct sockaddr_ll
{
  unsigned short sll_family; /* 总是 AF_PACKET */
  unsigned short sll_protocol; /* 物理层的协议 */
  int sll_ifindex; /* 接口号 */
  unsigned short sll_hatype; /* 报头类型 */
  unsigned char sll_pkttype; /* 分组类型 */
  unsigned char sll_halen; /* 地址长度 */
  unsigned char sll_addr[8]; /* 物理层地址 */
};
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2"><code>wpa_supplicant</code> 中 <code>l2_packet</code> 的初始化</h4>
<div class="outline-text-4" id="text-1-9-2">
<p>
初始化函数函数在 <code>l2_packet_init</code> ，设置接收不同的LLC层数据包类型。 
</p>

<p>
l2 packets的发送函数： <code>l2_packet_send</code>
驱动接口中接收EAPOL Packet的代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c">drv-&gt;eapol_sock = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_PAE));
if (drv-&gt;eapol_sock &lt; 0) {
        wpa_printf(MSG_ERROR, "nl80211: socket(PF_PACKET, SOCK_DGRAM, ETH_P_PAE) failed: %s",
                   strerror(errno));
        goto failed;
}

if (eloop_register_read_sock(drv-&gt;eapol_sock, handle_eapol, drv, NULL))
{
        wpa_printf(MSG_INFO, "nl80211: Could not register read socket for eapol");
        goto failed;
}
</pre>
</div>

<p>
负责处理的函数是 <code>handle_eapol</code> 。
</p>
</div>
</div>
<div id="outline-container-sec-1-9-3" class="outline-4">
<h4 id="sec-1-9-3">管理帧发送和接收</h4>
<div class="outline-text-4" id="text-1-9-3">
<p>
初始化RAW Socket，代码如下：
</p>
<div class="org-src-container">

<pre class="src src-c">static int hostap_init_sockets(struct hostap_driver_data *drv, u8 *own_addr)
{
        struct ifreq ifr;
        struct sockaddr_ll addr;

        drv-&gt;sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
        if (drv-&gt;sock &lt; 0) {
                wpa_printf(MSG_ERROR, "socket[PF_PACKET,SOCK_RAW]: %s",
                           strerror(errno));
                return -1;
        }

        ...

        return linux_get_ifhwaddr(drv-&gt;sock, drv-&gt;iface, own_addr);
}    
(src/drivers/driver_hosap.c)
</pre>
</div>

<p>
函数 <code>hostap_send_mlme</code> 发送管理帧，如发送 Probe Response. 
<code>handle_frame</code> 用于处理接收到的管理帧或数据帧等。
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10"><code>hostapd_setup_bss</code></h3>
<div class="outline-text-3" id="text-1-10">
<p>
Initialize Per-BSS data structures.
</p>

<div class="figure">
<p><img src="/images/2016/2016031501.png" alt="2016031501.png" />
</p>
</div>
</div>
</div>

<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">State Machine</h3>
<div class="outline-text-3" id="text-1-11">
</div><div id="outline-container-sec-1-11-1" class="outline-4">
<h4 id="sec-1-11-1">状态机的定义</h4>
<div class="outline-text-4" id="text-1-11-1">
<p>
文件路径 src/utils.h
此文件中定义了一些宏用于实现一个状态机
</p>
</div>
<ul class="org-ul"><li><a id="sec-1-11-1-1" name="sec-1-11-1-1"></a>总体说明<br  /><div class="outline-text-5" id="text-1-11-1-1">
<p>
首先，需要包含这个头文件，另外在实现文件中，有如下一些要求：
</p>
<ol class="org-ol">
<li>必须定义这个宏 <code>STATE_MACHINE_DATA</code> ，代表包含状态机变量的数据
结构
</li>
<li>定义宏 <code>STATE_MACHINE_DEBUG_PREFIX</code> 已保证输出该状态机相关的打
印消息时，有相关的前缀信息出来。
</li>
<li>宏 <code>SM_ENTRY_MA</code> 用于定义一组共享一个数据结构的状态机。
</li>
<li>宏 <code>STATE_MACHINE_ADDR</code> 定义到指向在调试输出中的MAC地址
</li>
<li>宏 <code>SM_ENTRY_M</code> 用于定义一组类似的状态机，只是不包含这些额外的
调试信息。
</li>
</ol>
</div>
</li>
<li><a id="sec-1-11-1-2" name="sec-1-11-1-2"></a>主要宏<br  /><div class="outline-text-5" id="text-1-11-1-2">
<ol class="org-ol">
<li><code>SM_STATE</code>
用于声明一个状态机的函数。 当调用 <code>SM_ENTER</code>,
<code>SM_ENTER_GLOBAL</code> ，进入当前状态。
<div class="org-src-container">

<pre class="src src-c">#define SM_STATE(machine, state) \
static void sm_ ## machine ## _ ## state ## _Enter(STATE_MACHINE_DATA *sm, \
        int global)
</pre>
</div>
</li>
<li><code>SM_ENTRY</code>
        状态机函数入口点，通常位于函数体的开头处。
<div class="org-src-container">

<pre class="src src-c">#define SM_ENTRY(machine, state) \
if (!global || sm-&gt;machine ## _state != machine ## _ ## state) { \
        sm-&gt;changed = TRUE; \
        wpa_printf(MSG_DEBUG, STATE_MACHINE_DEBUG_PREFIX ": " #machine \
                   " entering state " #state); \
} \
sm-&gt;machine ## _state = machine ## _ ## state;
</pre>
</div>
</li>
<li><code>SM_ENTRY_M</code>
        一组状态机的入口函数，定义与 <code>SM_ENTRY</code> 一样。
</li>
<li><code>SM_ENTRY_MA</code>
        与 <code>SM_ENTRY_M</code> 一样，只是在调试信息中加入了MAC地址信息。
</li>
<li><code>SM_ENTER</code>
        将状态机从一个状态转入另一个状态。
<div class="org-src-container">

<pre class="src src-c">#define SM_ENTER(machine, state) \
sm_ ## machine ## _ ## state ## _Enter(sm, 0)
</pre>
</div>
</li>
<li><code>SM_ENTER_GLOBAL</code> 
<div class="org-src-container">

<pre class="src src-c">#define SM_ENTER_GLOBAL(machine, state) \
sm_ ## machine ## _ ## state ## _Enter(sm, 1)
</pre>
</div>
</li>
<li><code>SM_STEP</code>
        声明一个状态机的step函数
<div class="org-src-container">

<pre class="src src-c">#define SM_STEP(machine) \
static void sm_ ## machine ## _Step(STATE_MACHINE_DATA *sm)
</pre>
</div>
</li>
<li><code>SM_STEP_RUN</code>
        调用一个状态机的step函数
<div class="org-src-container">

<pre class="src src-c">#define SM_STEP_RUN(machine) sm_ ## machine ## _Step(sm)
</pre>
</div>
</li>
</ol>
</div>
</li></ul>
</div>
<div id="outline-container-sec-1-11-2" class="outline-4">
<h4 id="sec-1-11-2">WPA/WPA2</h4>
<div class="outline-text-4" id="text-1-11-2">
</div><ul class="org-ul"><li><a id="sec-1-11-2-1" name="sec-1-11-2-1"></a>wpa state machine初始化<br  /><ul class="org-ul"><li><a id="sec-1-11-2-1-1" name="sec-1-11-2-1-1"></a>L2 Packet (EAPOL包)处理<br  /><div class="outline-text-6" id="text-1-11-2-1-1">
<p>
创建了一个链路层的套接字(<code>driver_nl802.11.c</code>)：
</p>
<div class="org-src-container">

<pre class="src src-c">drv-&gt;eapol_sock = socket(PF_PACKET, SOCK_DGRAM, htons(ETH_P_PAE));
</pre>
</div>
<p>
监听并处理EAPOL链路层数据包
</p>
<div class="org-src-container">

<pre class="src src-c">if (eloop_register_read_sock(drv-&gt;eapol_sock, handle_eapol, drv, NULL))
{
        printf("Could not register read socket for eapol\n");
        goto failed;
}
</pre>
</div>

<p>
处理流程：
</p>

<div class="figure">
<p><img src="/images/2016/2016011801.png" alt="2016011801.png" />
</p>
</div>

<ol class="org-ol">
<li>evnets.c  
<code>EVENT_EAPOL_RX</code>
在Association之前收到EAPOL包，会先缓存起来，等到Association成
功后，再处理。
</li>
<li><code>wpa_supplicant.c</code>
</li>
</ol>


<p>
<code>wpa_supplicant_set_state</code>
</p>
</div>
</li></ul>
</li>
<li><a id="sec-1-11-2-2" name="sec-1-11-2-2"></a>wpa Authenticator<br  /><div class="outline-text-5" id="text-1-11-2-2">
<p>
在 <code>hostapd_setup_wpa</code> 中会初始化 <code>wpa_authenticator</code>
(wpa<sub>auth</sub><sub>glue</sub>.h), 标记为： <code>WPA_PROTO_WPA</code> <code>WPA_PROTO_RSN</code>
</p>
</div>
</li>
<li><a id="sec-1-11-2-3" name="sec-1-11-2-3"></a>WPA supplicant<br  /><div class="outline-text-5" id="text-1-11-2-3">
<p>
WPA功能代码如下：
</p>
<ul class="org-ul">
<li><code>wpa.c and wpa.h</code> WPA state machine and 4-Way/Group Key Handshake
processing
</li>
<li><code>preauth.c and preauth.h</code> PMKSA caching and pre-authentication
(RSN/WPA2)
</li>
<li><code>wpa_i.h</code> Internal definitions for WPA code; not to be included
to other modules.
</li>
</ul>
</div>
</li></ul>
</div>
<div id="outline-container-sec-1-11-3" class="outline-4">
<h4 id="sec-1-11-3">EAPOL</h4>
<div class="outline-text-4" id="text-1-11-3">
<p>
IEEE 802.1X-2004 - Supplicant - EAPOL state machines
</p>
</div>
<ul class="org-ul"><li><a id="sec-1-11-3-1" name="sec-1-11-3-1"></a>EAPOL supplicant<br  /><div class="outline-text-5" id="text-1-11-3-1">
<p>
<code>eapol_supp_sm.c and eapol_supp_sm.h</code> EAPOL状态机和IEEE 802.1X处理。
</p>
</div>
</li>
<li><a id="sec-1-11-3-2" name="sec-1-11-3-2"></a>EAPOL Authenticator<br  /><div class="outline-text-5" id="text-1-11-3-2">
<p>
在 <code>ieee802_1x_init</code> 会初始化 <code>eapol_authenticator</code> 
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-11-4" class="outline-4">
<h4 id="sec-1-11-4">EAP</h4>
<div class="outline-text-4" id="text-1-11-4">
<p>
EAP Peer State Machine &amp; EAP Server State Machine, RFC4137 &amp; RFC3748
</p>
</div>

<ul class="org-ul"><li><a id="sec-1-11-4-1" name="sec-1-11-4-1"></a>EAP peer<br  /><div class="outline-text-5" id="text-1-11-4-1">
<p>
这个模块是个相对独立的模块，可单独使用。
相关文件说明如下：
</p>
<ul class="org-ul">
<li><code>eap.c and eap.h</code> EAP状态机和方法接口。
</li>
<li><code>eap_defs.h</code> 通用的EAP定义
</li>
<li><code>eap_i.h</code> EAP状态机和EAP方法的内部定义。
</li>
<li><code>eap_sim_common.c and eap_sim_common.h</code> <code>EAP-SIM</code> 和 <code>EAP-AKA</code> 的公用代
码。
</li>
<li><code>eap_tls_common.c and eap_tls_common.h</code> <code>EAP-PEAP, EAP-TTLS, and
        EAP-FAST</code> 公用代码
</li>
<li><code>eap_tlv.c and eap_tlv.h</code> <code>EAP-PEAP</code> 和 <code>EAP-FAST</code> 的 <code>EAP-TLV</code>
        代码。
</li>
<li><code>eap_ttls.c and eap_ttls.h</code> EAP-TTLS代码。
</li>
<li><code>eap_pax.c, eap_pax_common.h, eap_pax_common.c</code>  <code>EAP-PAX</code> 代码
</li>
<li><code>eap_psk.c, eap_psk_common.h, eap_psk_common.c</code> <code>EAP-PSK</code> 代码
</li>
<li><code>eap_sake.c, eap_sake_common.h, eap_sake_common.c</code> <code>EAP-SAKE</code> 代
码
</li>
<li><code>eap_gpsk.c, eap_gpsk_common.h, eap_gpsk_common.c</code> <code>EAP-GPSK</code> 代
码
</li>
<li><code>eap_aka.c, eap_fast.c, eap_gtc.c, eap_leap.c, eap_md5.c,
        eap_mschapv2.c, eap_otp.c, eap_peap.c, eap_-sim.c, eap_tls.c</code>
        其他EAP方法实现
</li>
</ul>
</div>
</li>

<li><a id="sec-1-11-4-2" name="sec-1-11-4-2"></a>EAP Server<br  /></li></ul>
</div>

<div id="outline-container-sec-1-11-5" class="outline-4">
<h4 id="sec-1-11-5">wpa statemachine状态变化</h4>
<div class="outline-text-4" id="text-1-11-5">
<p>
设置当前状态： <code>wpa_supplicant_set_state</code>
获取当前状态： <code>wpa_supplicant_get_state</code>
</p>

<p>
访问当前状态机的状态(公供wpa状态机内部调用)： 
</p>
<ol class="org-ol">
<li>获取当前状态机的状态：  <code>wpa_sm_get_state</code>
</li>
<li>设置当前状态机的状态:  <code>wpa_sm_set_state</code> 
</li>
</ol>
</div>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><code>wpa_supplicant</code> 功能模块分析</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">P2P</h3>
<div class="outline-text-3" id="text-2-1">
</div><div id="outline-container-sec-2-1-1" class="outline-4">
<h4 id="sec-2-1-1">数据结构分析与初始化流程</h4>
<div class="outline-text-4" id="text-2-1-1">
</div><ul class="org-ul"><li><a id="sec-2-1-1-1" name="sec-2-1-1-1"></a>主要数据结构<br  /></li>

<li><a id="sec-2-1-1-2" name="sec-2-1-1-2"></a>初始化流程<br  /><div class="outline-text-5" id="text-2-1-1-2">
<p>
当Driver支持一个非网络接口的P2P Device接口时,
</p>
<div class="org-src-container">

<pre class="src src-c">/* Driver supports a dedicated interface for P2P Device */
#define WPA_DRIVER_FLAGS_DEDICATED_P2P_DEVICE           0x20000000
</pre>
</div>
<p>
先做 <code>wpa_drv_if_add</code> ，然后进行 <code>wpa_supplicant_add_iface</code> 。
否则，则从 <code>wpa_supplicant_add_iface</code> 开始执行。
</p>


<div class="figure">
<p><img src="/images/2016/2016020101.png" alt="2016020101.png" />
</p>
</div>

<p>
在 <code>p2p_init</code> 函数中，同时也注册了一个 循环超时检测函数
<code>p2p_expiration_timeout</code> ，这个函数会周期性检查当前P2P Peers端是
否处于活跃状态（当我们是GO的时候，需要做这样的检查，以维护peer
device list列表）
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-1-2" class="outline-4">
<h4 id="sec-2-1-2">基本连接流程</h4>
<div class="outline-text-4" id="text-2-1-2">
</div><ul class="org-ul"><li><a id="sec-2-1-2-1" name="sec-2-1-2-1"></a>一般连接过程<br  /><div class="outline-text-5" id="text-2-1-2-1">

<div class="figure">
<p><img src="/images/2016/2016071202.png" alt="2016071202.png" />
</p>
<p><span class="figure-number">Figure 13:</span> P2P Standard Group Formation</p>
</div>

<ol class="org-ol">
<li>首先，P2P设备要能发现对方，会通过扫描来进行：要么在1，6，11信道
上主动发送Probe Request来侦测P2P设备，要么停留在某个信息侦测
Beacon或Probe Reqeust帧。
</li>
<li>在建立P2P组前，可以询问被发现的P2P设备支持哪些服务。
</li>
<li>当决定跟被发现的P2P设备连接时，可以邀请一个已经加一个了某个P2P
组的P2P设备加入一个新的P2P组，或与一个未连接的P2P设备通过GO协
商过程形成一个新的P2P组。
会经历GO-NEGOTIATION-REQUEST和GO-NEGOTIATION-RESPONSE两步交互
过程，一旦协商完成，发起方会发送一个
GO-NEGOTIATION-CONFIRMATION，然后两个设备都会切换到协商好的信道
上去进行通信。
GO会不停地发送Beacon帧，携带协商的BSSID信息，且 <code>group
         formation bit</code> 会置为1，因为此时，P2P成组过程还没有结束。
</li>
<li>然后是 <code>Provisioning</code> 阶段开始，P2P Client会连接GO，通过WPS协
议来交换 <code>credentials</code> 信息，实质上是一些EAP消息的交互（M1~M8）  
当加入一个现存的P2P组时，或为了加快 <code>provisioning</code> 阶段，设备
可以在进行Group协商之前执行 <code>Provision Discovery
         request/response</code> . 如果不这样，GO Negotiation会失败。必须在后
续重新启动协商过程。
</li>
<li>之后 ，会进行关联，4-way握手过程，以交换密钥。 之后，GC会向GO
请求一个IPv4的地址，GO需要实现DHCP服务器的功能。

<p>
为了免掉每次Group创建过程中，需要输入PIN码的麻烦，可以将P2P组
设为 <code>persistent</code> 的，这样它会存储 <code>credentials</code> 信息，并在适
当的时候重新连接 。 
</p>

<p>
<a href="http://processors.wiki.ti.com/index.php/OMAP_Wireless_Connectivity_NLCP_WiFi_Direct_Configuration_Scripts">http://processors.wiki.ti.com/index.php/OMAP_Wireless_Connectivity_NLCP_WiFi_Direct_Configuration_Scripts</a>
</p>


<div class="figure">
<p><img src="/images/2016/2016012501.png" alt="2016012501.png" />
</p>
</div>
</li>
</ol>
</div>
</li>

<li><a id="sec-2-1-2-2" name="sec-2-1-2-2"></a>收到Invitation Request的交互过程<br  /><div class="outline-text-5" id="text-2-1-2-2">

<div class="figure">
<p><img src="/images/2016/2016071203.png" alt="2016071203.png" />
</p>
<p><span class="figure-number">Figure 15:</span> P2P Persisten Group Formation</p>
</div>

<ol class="org-ol">
<li>当前设置处于 <code>P2P_Find</code> 阶段时，如果收到 <code>Invitation Request</code>
Action帧，即 <code>P2P: Received Invitation Request from
        86:38:38:b0:ff:ee (freq=2462)</code> ，则首先会解析该Action帧携带的一些
信息，然后将该设备添加到设备列表中，并报告有新的设备发现。
</li>
<li>创建一个p2p接口。 
<code>P2P: Create a new interface p2p-p2p0-0 for the group</code>
<code>nl80211: Create interface iftype 9 (P2P_GO)</code>
</li>
<li>发送 <code>Invitation Response</code> Action帧给对端。并回调
<code>p2p_inviation_resp_cb</code> , 它会调用 <code>wpas_invitation_received</code>
。
</li>
<li>调用 <code>p2p_stop_find</code> 。
</li>
</ol>
</div>
</li>

<li><a id="sec-2-1-2-3" name="sec-2-1-2-3"></a>Driver 当GC时的交互过程：<br  /><div class="outline-text-5" id="text-2-1-2-3">
<pre class="example">
1. CFG80211_PKT: RX P2P_PROVISION_REQ 11
2. CFG80211_PKT: TX P2P_PROVISION_RSP 11
3. CFG80211_PKT: RX GO_NEGOCIACTION_REQ 11
4. CFG80211_PKT: TX GO_NEGOCIACTION_RSP 11
   这时，会启动Virutal Inferace： RTMP_CFG80211_VirtualIF_Init

5. CFG80211_OpsRemainOnChannel   listen
6. CFG80211_PKT: TX GO_NEGOCIACTION_REQ 11
7. CFG80211_PKT: RX GO_NEGOCIACTION_RSP 11
8. CFG80211_PKT: TX GO_NEGOCIACTION_CONFIRM 11
   CFG80211_VirtualIF_Open, 会出现："(ApCliIfUp) ApCli can't startup Due to CFG80211 No connect yet."
9. CFG80211_OpsConnect
   80211&gt; Connect bssid 16:f6:5a:ac:92:0e
   APCLI Connection onGoing.....
   AP_CLI WPS Connection onGoing.....
   80211&gt; APCLI CONNECTING SSID = DIRECT-si-
   Set_ApCli_Enable_Proc::(enable = 1)
   (ApCliIfDown) ApCli interface[0] startdown.
   80211&gt; APCLI CONNECTING SSID = DIRECT-si-
   80211&gt; CFG80211_OpsStaChg ==&gt;
   80211&gt; Change STA(00:00:00:00:00:00) ==&gt;
   80211&gt; CFG80211_OpsStaChg ==&gt;
   80211&gt; Change STA(00:00:00:00:00:00) ==&gt;
   80211&gt; CFG80211_OpsStaChg ==&gt;
   80211&gt; Change STA(00:00:00:00:00:00) ==&gt;
   80211&gt; CFG80211_OpsStaChg ==&gt;
   80211&gt; Change STA(00:00:00:00:00:00) ==&gt;
   (ApCliIfUp) ApCli interface[0] startup.
   (ApCliCtrlJoinReqAction) Start Probe Req.
   ApCli SYNC - Start Probe the SSID  on channel =1
   SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
   = 1
   PeerBeaconAtJoinAction HT===&gt;Central Channel = 1, Control
   Channel = 1,  .
   APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
   APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
   APCLI_ASSOC - Send ASSOC request...
   ApCliPeerAssocRspSanity() found wfd ie in assoc response frame,
   it's wfd connect.
   APCLI_ASSOC - receive ASSOC_RSP to me (status=0)
   ApCliPeerAssocRspAction:: recv peer ASSOC RSP from
   16:f6:5a:ac:92:0e.    bP2pClient = 1
   ApCliAssocPostProc===&gt; 11n HT STA
   !!! APCLI LINK UP - IF(apcli0) AuthMode(0)=OPEN,
   WepStatus(1)=NONE !!!
   MacTableInsertEntry - allocate entry #2, Total= 1
   80211&gt; CFG80211_OpsStaChg ==&gt;
   80211&gt; Change STA(16:F6:5A:AC:92:0E) ==&gt;
   =WPS-Start=
   Receive EAP-Packet frame, TYPE = 0, Length = 5
   CFG80211 EAPOL Indicate_Legacy_Packet
   CFG80211_PKT: RX ACTION Frame 1
   CFG80211_PKT: P2P_CHECK ACTION Frame 1
   80211&gt; CFG80211_OpsDisconnect ==&gt;
   80211&gt; ReasonCode = 3
   AUTH - Send DE-AUTH request (Reason=3)..
   !!! APCLI LINK DOWN - IF(apcli0)!!!   
   =WPS-End=
   ++++++++ ApCliLinkDown::  Keep BssTable on Channel
   = 1. ++++++++      BSSID = [16:f6:5a:ac:92:0e].  p2p_bssid =
   [16:f6:5a:ac:92:0e].
   80211&gt; CFG80211_LostGoInform ==&gt; 
   (ApCliIfDown) ApCli interface[0] startdown.

   80211&gt; CFG80211_OpsConnect ==&gt;

   =4-way-handshake=
   80211&gt; Connect bssid 16:f6:5a:ac:92:0e
   (ApCliIfUp) ApCli interface[0] startup.
   (ApCliCtrlJoinReqAction) Start Probe Req.
   SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
   = 1
   ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
   Scanning!!
   APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
   APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
   APCLI_ASSOC - Send ASSOC request...
   ApCliMlmeAssocReqAction:: APCLI WPA_ASSOC_IE FROM SUPPLICANT
   (ApCliCtrlAssocReqTimeoutAction) Assoc Req Timeout.

   (ApCliIfUp) ApCli interface[0] startup.

   (ApCliCtrlJoinReqAction) Start Probe Req.
   SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
   = 1
   ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
   Scanning!!
   APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
   Deauth: 7e:b2:32:e7:7c:25, 16:f6:5a:ac:92:0e
   APCLI AUTH_RSP - receive DE-AUTH from our AP
   APCLI AUTH - AuthTimeout
   (ApCliIfUp) ApCli interface[0] startup.
   (ApCliCtrlJoinReqAction) Start Probe Req.
   SYNC - receive desired PROBE_RSP at JoinWaitProbeRsp... Channel
   = 1
   ApCliPeerProbeRspAtJoinAction::  Swich Channel = 1. and STOP
   Scanning!!

   APCLI AUTH - Send AUTH request seq#1 (Alg=0)...
   APCLI AUTH - Receive AUTH_RSP seq#2 to me (Alg=0, Status=0)
   (ApCliCtrlAuthRspAction) Auth Rsp Success.
   APCLI_ASSOC - Send ASSOC request...
   APCLI_ASSOC - receive ASSOC_RSP to me (status=0)
   ApCliPeerAssocRspAction:: recv peer ASSOC RSP from
   16:f6:5a:ac:92:0e.    bP2pClient = 1

   !!! APCLI LINK UP - IF(apcli0) AuthMode(7)=WPA2PSK,
   WepStatus(6)=AES !!!

   MacTableInsertEntry - allocate entry #2, Total= 1

   Receive EAPOL-Key frame, TYPE = 3, Length = 95
   CFG80211 EAPOL Indicate_Legacy_Packet
   80211&gt; CFG80211_OpsKeyAdd ==&gt;
   AsicAddSharedKeyEntry BssIndex=8, KeyIdx=1

   !!!P2P Group STARTED

   DHCP
   DHCP_DISCOVER
   DHCP_OFFER
   DHCP_REQUEST
   DHCP_ACK
</pre>
</div>
</li>

<li><a id="sec-2-1-2-4" name="sec-2-1-2-4"></a>Driver当GO时的交互过程：<br  /><div class="outline-text-5" id="text-2-1-2-4">
<pre class="example">
1. P2P Listen  
   CFG80211_PKT: ROC CHANNEL_LOCK 11
   CFG80211_PKT: TX ProbeRsp Frame 11
   CFG80211_PKT: TX ProbeRsp Frame 11

2. Receive P2P Invite
   CFG80211_PKT: RX P2P_INVITE_REQ 11
   CFG80211_PKT: TX P2P_INVITE_RSP 11

3. CFG80211_PKT: RX GO_NEGOCIACTION_REQ 11

4. CFG80211_PKT: TX GO_NEGOCIACTION_REQ 1

5. CFG80211_PKT: RX GO_NEGOCIACTION_RSP 1

6. CFG80211_PKT: TX GO_NEGOCIACTION_CONFIRM 1

7. GroupNegotiatioCFG80211_VirtualIF_Open: ===&gt; 8,p2p-p2p0-2
   rocessMessage   (ApCliIfUp) ApCli can't startup Due to
   CFG80211 No connect yet.
   ==&gt; RTMP_CFG80211_VirtualIF_CancelP2pClient.
   ==&gt; RTMP_CFG80211_VirtualIF_CancelP2pClient HIT.
   80211&gt; Change to IFTYPE_AP 3!
   80211&gt; Change the Interface to AP Mode
   80211&gt; CFG80211_OpsStaDel ==&gt;
   Deauthenticate all stations!

8. 80211&gt; Set the channel in AP Mode
   80211&gt; CFG80211DRV_OpsBeaconSet ==&gt; 1
   New AP BSSID 7e:b2:32:e7:7c:25
   CFG80211_PKT: TX ProbeRsp Frame 11
   AUTH - MBSS(0), Rcv AUTH seq#1, Alg=0, Status=0 from
   [wcid=255]86:38:38:b0:7f:ee
   AUTH_RSP - Send AUTH response (SUCCESS)...
   ASSOC - MBSS(0), receive ASSOC request from
   86:38:38:b0:7f:ee
   SSOC - Send ASSOC response (Status=0)...
   =WPS=
   ####### Send L2 Frame Mac=86:38:38:b0:7f:ee
   CFG80211_PKT: RX ACTION Frame 11
   CFG80211 EAPOL Indicate_Legacy_Packet

9. P2P_GROUP_STARTED_STR
   ASSOC - receive DIS-ASSOC(seq-1765) request from
   86:38:38:b0:7f:ee, reason=8

   AUTH_RSP - Send AUTH response (SUCCESS)...
   ASSOC - Send ASSOC response (Status=0)...
   =4-way handshake=
   ####### Send L2 Frame Mac=86:38:38:b0:7f:ee
</pre>
</div>
</li>

<li><a id="sec-2-1-2-5" name="sec-2-1-2-5"></a>Action帧的接收<br  /><div class="outline-text-5" id="text-2-1-2-5">

<div class="figure">
<p><img src="/images/2016/2016012901.png" alt="2016012901.png" />
</p>
</div>
</div>
</li>

<li><a id="sec-2-1-2-6" name="sec-2-1-2-6"></a>Action帧的发送<br  /><div class="outline-text-5" id="text-2-1-2-6">
<p>
Action帧发送后，Driver会反馈发送的状态，即发送成功与否。
</p>

<p>
通过 <code>struct p2p_cfg</code> 的回调接口： <code>send_action</code> ， 实际注册的
函数为： <code>wpas_send_action</code> , 该函数会调用
<code>offchannel_send_action</code> ，并注册了回调函数 :
<code>wpas_p2p_send_action_tx_status</code> ， 通过该接口，将发送Action帧
的结果反馈上来。底层是通过  <code>EVENT_TX_STATUS</code> 消息来通知的，通
过调用 <code>offchannel_send_action_tx_status</code> 来回调注册的函数。
</p>


<div class="figure">
<p><img src="/images/2016/2016012902.png" alt="2016012902.png" />
</p>
</div>
</div>
</li>

<li><a id="sec-2-1-2-7" name="sec-2-1-2-7"></a>p2p协商时信道的选择<br  /><div class="outline-text-5" id="text-2-1-2-7">
<ol class="org-ol">
<li>在获取peer信息前，选择oper Channel
<pre class="example">
p2p_prepare_channel
</pre>
</li>
<li>在获取peer信息后， 调用如下函数进行优化
<pre class="example">
p2p_reselect_channel
</pre>
</li>
</ol>
</div>
</li></ul>
</div>

<div id="outline-container-sec-2-1-3" class="outline-4">
<h4 id="sec-2-1-3">p2p管理</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
当 <code>wpa_s-&gt;drv_flags</code> &amp; <code>WPA_DRIVER_FLAGS_P2P_MGMT</code> 为真时，代表相关的P2P
管理操作会由Driver去实现。上层对P2P的一些操作，最终会透过netlink发
送给Driver。
</p>

<p>
当然，如果Driver并没有实现p2p管理的相关工作，则会在
<code>wpa_supplicant</code> 这层来做。目前从代码看来，p2p管理相关的工作没有放到Driver中去做。
</p>

<p>
<code>wpa_supplicant</code> 在文件 <code>p2p_supplicant.c</code> 这个文件中注册了许多p2p管理相关
的函数接口。
</p>
</div>
</div>

<div id="outline-container-sec-2-1-4" class="outline-4">
<h4 id="sec-2-1-4">Go创建</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
入口函数： <code>wpa_driver_nl80211_set_ap</code> 
Ignore deauth event in AP mode
两个相关的NL80211命令：
</p>
<ul class="org-ul">
<li><code>NL80211_CMD_NEW_BEACON</code>
</li>
<li><code>NL80211_CMD_SET_BSS</code>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-5" class="outline-4">
<h4 id="sec-2-1-5">socket control interface</h4>
<div class="outline-text-4" id="text-2-1-5">
<ul class="org-ul">
<li><code>p2p_find</code>  
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>p2p_find</code> [timeout (seconds)] [type &lt;social \ progressive&gt;] [ <code>dev_id</code> =] [delay=]</td>
<td class="left">Enables discovery – start sending probe request frames</td>
</tr>
</tbody>
</table>

<p>
p2p<sub>find默认的行为是开始做一次全信道扫描，然后扫描特定的信道。</sub> 
参数说明如下：
</p>
<ul class="org-ul">
<li>当type=social时，只会扫描社会信息，会跳过第一次全信道扫描。
</li>

<li>当type=progressive时，行为类似默认情况下的行为，只不过在每一次
Search状态的回合中，依次扫描一个信道。
</li>

<li>dev<sub>id</sub> : 可以指定单个要扫描的对端设备。
</li>

<li>delay: 是一个延时值。 
</li>
</ul>
</li>
</ul>


<p>
当接受到 <code>p2p_find</code> 命令时，会进入入口函数： <code>p2p_ctrl_find</code> ，
此时会决定两个参数：
</p>
<ol class="org-ol">
<li>扫描的类型
</li>
<li>延时扫描的时间，即等待多久后，进行p2p find的动作。
</li>
</ol>

<p>
接下来会进入 <code>wpas_p2p_find</code> 函数，如果当前的SSID的模式为
<code>WPAS_MODE_P2P_GO</code> 或 <code>WPAS_MODE_P2P_GROUP_FORMATION</code> ， 会停止
p2p find的动作。 
</p>

<p>
然后，会清掉一些未决的Action帧的传输动作。 如果P2P管理的功能实现
在 driver 层，则直接进入 函数： <code>wpa_drv_p2p_find</code> ， 通过
NL80211触发Driver直接 p2p find动作。 否则，则会进入 <code>p2p_find</code>
， 在此之前，会取消规划的扫描动作。 
</p>

<p>
这些函数会准备执行 p2p find 所需要的一些参数 ，然后调用到
p2p-&gt;cfg-&gt;p2p<sub>scan</sub> 回调接口。 它有三种返回值：
</p>
<ul class="org-ul">
<li>0: 扫描请求发送成功，设置扫描超时时间。
</li>
<li>1: 扫描请求失败，会等待上一个扫描动作完成后，再进行尝试，当前
P2P状态机置为： <code>P2P_SEARCH_WHEN_READY</code> , 表示有个未决的扫描动
作。相关函数： <code>p2p_search_pending</code>
<code>p2p_other_scan_completed</code> 
</li>
<li>其他值： 扫描请求失败。 
</li>
</ul>

<p>
在 <code>p2p_supplicant.c</code> 文件中，定义了p2p 初始化的函数，里面有定义
对应的回调接口： <code>wpas_p2p_scan</code> 。  在该函数中，会通过
<code>wpa_drv_scan</code> 将扫描请求发送给Driver， 并指定扫描结果的处理回回
调接口： <code>wpas_p2p_scan_res_handler</code> 
</p>

<ul class="org-ul">
<li><code>p2p_stop_find</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>p2p_stop_find</code></td>
<td class="left">Stops discovery, or whatever you are doing (listen mode, connection process etc.)</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_connect</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">&#xa0;</td>
<td class="left"><code>GO_intent</code> – initiate connection to another device (using entered group intent)</td>
</tr>

<tr>
<td class="left"><code>p2p_connect</code> &lt;device address&gt; &lt;PBC \ PIN&gt; [ <code>GO_intent</code> =&lt;0-15&gt; \ auth \ join]</td>
<td class="left">Auth – WPS authorize incoming connection</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">Join – connect to an existing GO</td>
</tr>

<tr>
<td class="left">&#xa0;</td>
<td class="left">No input – initiate connection using default GO intent</td>
</tr>
</tbody>
</table>

<p>
这个命令直接会入口函数是 <code>p2p_ctrl_connect</code> ， 在解析
<code>p2p_connect</code> 命令的参数后， 会进入  <code>wpas_p2p_connect</code> ，里面会
执行一些重要的步骤：
</p>
<ul class="org-ul">
<li><code>wpas_p2p_add_group_interface</code> 创建P2P虚拟接口
</li>
<li><code>wpas_p2p_auth_go_neg</code> 只确认协商时使用的信息
</li>
<li><code>wpas_p2p_start_go_neg</code> 开始 GO NEGOTIATION。
</li>
</ul>
<p>
在wps完成后，会启动重新关联过程,标记所有网络为禁用状态，从而触发
Roaming过程：
</p>
<pre class="example">
wpas_wps_temp_disable(wpa_s, selected);
wpa_s-&gt;reassociate = 1;
</pre>
</li>

<li><code>p2p_listen</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_listen</code> [timeout (seconds)]</td>
<td class="left">Enable listen mode</td>
</tr>
</tbody>
</table>

<p>
Listen状态可能不会立即开始，因为可能会有其他未决的操作正在进行，
一旦进入Listen状态，会调用p2p<sub>listen</sub><sub>cb</sub>()函数通知P2P模块。一旦退
出Listen状态，会调用p2p<sub>listen</sub><sub>end</sub>()函数通知P2P模块已经不再处于
Listen状态了。
</p>

<p>
<code>p2p_listen</code> 流程分析：
应用程序进入Miracast后，一般会调用 <code>p2p_listen</code> 命令，监听附近的
WFD Source设备， 大致流程如下：
</p>

<div class="figure">
<p><img src="/images/2016/2016061001.png" alt="2016061001.png" />
</p>
</div>

<p>
在监听的过程，当驱动收到Probe Request请求后，会通过
<code>cfg80211_rx_mgmt</code> 上报给内核，并最终通知给 <code>wpa_supplicant</code> ，
调用路径为：
</p>

<div class="figure">
<p><img src="/images/2016/2016061201.png" alt="2016061201.png" />
</p>
</div>
</li>

<li><code>p2p_group_remove</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_group_remove</code> &lt;interface&gt;</td>
<td class="left">Remove device from group, return to device mode if acting as GO or autonomous GO</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_group_add</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_group_add</code></td>
<td class="left">Become an autonomous GO</td>
</tr>

<tr>
<td class="left"><code>P2p_group_remove</code> &lt;interface&gt;</td>
<td class="left">Remove device from group, return to device mode if acting as GO or autonomous GO</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_prov_disc</code>
</li>

<li><code>p2p_get_passphrase</code>
</li>
<li><code>p2p_serv_disc_req</code>
</li>
<li><code>p2p_serv_disc_cancel_req</code>
</li>
<li><code>p2p_serv_disc_resp</code>
</li>
<li><code>p2p_service_update</code>
</li>
<li><code>p2p_serv_disc_external</code>
</li>
<li><code>p2p_service_flush</code>
</li>
<li><code>p2p_service_add</code>
</li>
<li><code>p2p_service_del</code>
</li>
<li><code>p2p_reject</code>
</li>
<li><code>p2p_invite</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>p2p_invite</code> &lt;cmd&gt; [address]</td>
<td class="left">Send invitation to device</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_peers</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_peers</code> [discovered]</td>
<td class="left">Shows list of discovered peers (with ‘discovered’ – shows only fully discovered peers)</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_peer</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_peer</code> &lt;address&gt;</td>
<td class="left">Show detailed information about discovered peers</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_set</code>
</li>
<li><code>p2p_flush</code>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Command</th>
<th scope="col" class="left">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left"><code>P2p_flush</code></td>
<td class="left">Flush p2p<sub>state</sub>, and clears the discovered peer list</td>
</tr>
</tbody>
</table>
</li>
<li><code>p2p_presence_req</code>
</li>
<li><code>p2p_ext_listen</code>
</li>
<li><code>p2p_group_idle</code> 
Maximum idle time in seconds for P2P group
当一个p2p group建立起来后，GO等待GC连接的最大等待时间，或GC发现
GO的最大超时时间。
<div class="org-src-container">

<pre class="src src-c">/*
 * How many seconds to try to reconnect to the GO when connection in P2P client
 * role has been lost.
 */
#define P2P_MAX_CLIENT_IDLE 10
</pre>
</div>

<p>
group timeout相关Log：
</p>
<pre class="example">
05-25 10:42:50.650 D/wpa_supplicant( 2963): P2P: Group idle timeout reached - terminate group
05-25 10:42:50.650 D/wpa_supplicant( 2963): p2p0: Request to deauthenticate - bssid=00:00:00:00:00:00 pending_bssid=00:00:00:00:00:00 reason=3 state=SCANNING
05-25 10:42:50.651 D/wpa_supplicant( 2963): TDLS: Tear down peers
05-25 10:42:50.651 D/wpa_supplicant( 2963): p2p0: State: SCANNING -&gt; DISCONNECTED
05-25 10:42:50.651 D/wpa_supplicant( 2963): nl80211: Set p2p0 operstate 0-&gt;0 (DORMANT)
05-25 10:42:50.651 D/wpa_supplicant( 2963): netlink: Operstate: ifindex=5 linkmode=-1 (no change), operstate=5 (IF_OPER_DORMANT)
05-25 10:42:50.651 D/wpa_supplicant( 2963): CTRL_IFACE monitor sent successfully to /data/misc/wifi/sockets/wpa_ctrl_624-2\x00
05-25 10:42:50.651 D/wpa_supplicant( 2963): EAPOL: External notification - portEnabled=0
05-25 10:42:50.651 D/wpa_supplicant( 2963): EAPOL: External notification - portValid=0
05-25 10:42:50.651 I/wpa_supplicant( 2963): P2P-GROUP-REMOVED p2p0 client reason=IDLE


D/wpa_supplicant( 7409 7409): nl80211: Set supplicant port unauthorized for 00:00:00:00:00:00
I/wpa_supplicant( 7409 7409): P2P-GROUP-REMOVED p2p-p2p0-0 client reason=GO_ENDING_SESSION
D/wpa_supplicant( 7409 7409): CTRL_IFACE monitor send - hexdump(len=21): 2f 74 6d 70 2f 77 70 61 5f 63 74 72 6c 5f 37 36 32 2d 32 34 00
D/wpa_supplicant( 7409 7409): P2P: Cancelled P2P group idle timeout
D/wpa_supplicant( 7409 7409): P2P: Remove group interface p2p-p2p0-0
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-1-6" class="outline-4">
<h4 id="sec-2-1-6">nl80211 (p2p)</h4>
<div class="outline-text-4" id="text-2-1-6">
<ul class="org-ul">
<li><code>NL80211_CMD_REMAIN_ON_CHANNEL</code>
</li>
<li><code>NL80211_CMD_CANCEL_REMAIN_ON_CHANNEL</code>  

<p>
This indicates to the device that it should stay on a given
channel for a given time, to implement a P2P listen phase. Can
also be canceled, since it is also used to implement off-channel
TX for group negotiation or invitation
</p>
</li>

<li><code>NL80211_CMD_FRAME (previously NL80211_CMD_ACTION)</code>

<p>
传输一个管理帧。
</p>
</li>

<li><code>NL80211_CMD_REGISTER_FRAME</code>

<p>
通过nl80211，用户程序可以注册接收指定类型的管理帧。
</p>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-1-7" class="outline-4">
<h4 id="sec-2-1-7">问题调试</h4>
<div class="outline-text-4" id="text-2-1-7">
</div><ul class="org-ul"><li><a id="sec-2-1-7-1" name="sec-2-1-7-1"></a>P2p Standard Group Formation<br  /><div class="outline-text-5" id="text-2-1-7-1">
<ul class="org-ul">
<li>Could not find peer or be found by peer
<ul class="org-ul">
<li>Check if framework triggered p2p find phase by <code>P2P_FIND</code>
</li>
<li>If so,  check if probe request/response handshake works
ok(sniffer if possible)
</li>
</ul>
</li>
<li>Scan issues
<ul class="org-ul">
<li>Check if has GO beacons and probe request from box and
probe response from GO when acts as GC
</li>
<li>Check if box has tx beacon and RX probe request from peer
when acts as GO(sniffer if possible)
</li>
<li>WPS handshake issues
<ul class="org-ul">
<li>Check if WPS EAP handshake work ok in tcpdump log
</li>
<li>Need sniffer if WPS handshake not complete
</li>
</ul>
</li>
<li>4-way handshake issues
<ul class="org-ul">
<li>Check if 4-way handshake work ok in tcpdump log
</li>
<li>Need sniffer if 4-way handshake not complete
</li>
</ul>
</li>
<li>DHCP issues
<ul class="org-ul">
<li>Check if DHCP handshake work OK in tcpdump log
</li>
<li>Need sniffer
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</li>

<li><a id="sec-2-1-7-2" name="sec-2-1-7-2"></a>P2P persistent Group Formation<br  /><div class="outline-text-5" id="text-2-1-7-2">
<ul class="org-ul">
<li>Invitation request/response handshake work ok(need sniffer)
</li>
<li>4-way handshake issues
</li>
<li>DHCP issues
</li>
</ul>
</div>
</li></ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">bgscan (roaming) IAPP(Inter Access Point Protocol)</h3>
<div class="outline-text-3" id="text-2-2">
<p>
<code>WPA_Supplicant</code> has a module that is called 'bgscan' which features
a mode called 'simple'. This module can be configured to perform
periodic background scans when the signal level drops under a
certain level and when it finds a stronger AP during the scan it
can 'roam' when the difference between the AP's is significant
enough.
</p>

<p>
I also found that this module was compiled, present and
functioning by default. The only missing piece is that the
configuration line in the wpa<sub>supplicant</sub>.conf is missing
preventing the bgscan module from loading. I added the line into
the section for the relevant network:
</p>

<p>
bgscan="simple:120:-75:600"
</p>

<p>
The syntax for the configuration line is as follows and it should
be placed in the network section rather than the global section:
</p>

<p>
bgscan="simple:&lt;short bgscan interval in seconds&gt;:&lt;signal strength
threshold&gt;:&lt;long interval&gt;"
</p>

<p>
My bgscan simple line implies that if the signal is
stronger/better than -75db it will perform a bgscan every 10
minutes, if the signal is worse it will perform a scan every 2
minutes.
</p>

<p>
This is what a successful 'roam' looks like:
</p>
<pre class="example">
D/wpa_supplicant(  716): bgscan simple: Request a background scan
D/wpa_supplicant(  716): Scan requested (ret=0) - scan timeout 30 seconds
D/wpa_supplicant(  716): nl80211: Event message available
D/wpa_supplicant(  716): nl80211: Scan trigger
D/wpa_supplicant(  716): nl80211: Event message available
D/wpa_supplicant(  716): nl80211: Scan aborted
D/wpa_supplicant(  716): wlan0: Event SCAN_RESULTS (3) received
D/wpa_supplicant(  716): nl80211: Associated on 2412 MHz
D/wpa_supplicant(  716): nl80211: Associated with 68:7f:74:75:1c:7e
D/wpa_supplicant(  716): nl80211: Received scan results (2 BSSes)
D/wpa_supplicant(  716): nl80211: Survey data missing
D/wpa_supplicant(  716): nl80211: Scan results indicate BSS status with 68:7f:74:75:1c:7e as associated
D/wpa_supplicant(  716): wlan0: BSS: Start scan result update 527
D/wpa_supplicant(  716): wlan0: BSS: Add new id 97 BSSID 00:1e:2a:21:f7:3d SSID 'pakjebakmeel24'
D/wpa_supplicant(  716): CTRL_IFACE monitor send - hexdump(len=39): 2f 64 61 74 61 2f 6d 69 73 63 2f 77 69 66 69 2f 73 6f 63 6b 65 74 73 2f 77 70 61 5f 63 74 72 6c ...
D/wpa_supplicant(  716): wlan0: New scan results available
D/wpa_supplicant(  716): CTRL_IFACE monitor send - hexdump(len=39): 2f 64 61 74 61 2f 6d 69 73 63 2f 77 69 66 69 2f 73 6f 63 6b 65 74 73 2f 77 70 61 5f 63 74 72 6c ...
D/wpa_supplicant(  716): bgscan simple: scan result notification
D/wpa_supplicant(  716): wlan0: Selecting BSS from priority group 2
D/wpa_supplicant(  716): wlan0: 0: 00:1e:2a:21:f7:3d ssid='pakjebakmeel24' wpa_ie_len=0 rsn_ie_len=20 caps=0x431 level=-71
D/wpa_supplicant(  716): wlan0:    selected based on RSN IE
D/wpa_supplicant(  716): wlan0:    selected BSS 00:1e:2a:21:f7:3d ssid='pakjebakmeel24'
D/wpa_supplicant(  716): wlan0: Considering within-ESS reassociation
D/wpa_supplicant(  716): wlan0: Current BSS: 68:7f:74:75:1c:7e level=-79
D/wpa_supplicant(  716): wlan0: Selected BSS: 00:1e:2a:21:f7:3d level=-71
D/wpa_supplicant(  716): wlan0: Saving prev AP info for roaming recovery - SSID ID: 1 BSSID: 68:7f:74:75:1c:7e
D/wpa_supplicant(  716): wlan0: Request association: reassociate: 0  selected: 00:1e:2a:21:f7:3d  bssid: 68:7f:74:75:1c:7e  pending: 00:00:00:00:00:00  wpa_state: COMPLETED
I/wpa_supplicant(  716): wlan0: EPBUG: Going to authenticate
</pre>

<p>
<a href="https://android.googlesource.com/platform/external/wpa_supplicant_8/+/ics-plus-aosp/wpa_supplicant/bgscan_simple.c">https://android.googlesource.com/platform/external/wpa_supplicant_8/+/ics-plus-aosp/wpa_supplicant/bgscan_simple.c</a>
</p>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">WPS</h3>
<div class="outline-text-3" id="text-2-3">
<p>
在P2P GO与GC关联后，会进行WPS交互过程。交互时的一些信息会透过
Association Request携带的IE信息来提供，如果底层驱动上报的
Association Request中相关的IE信息为空，则WPS过程将会终止。
在GO协议完成后，会开始WPS协商的过程。
</p>


<div class="figure">
<p><img src="/images/2016/2016031007.png" alt="2016031007.png" />
</p>
</div>
</div>

<div id="outline-container-sec-2-3-1" class="outline-4">
<h4 id="sec-2-3-1">Enrollee</h4>
<div class="outline-text-4" id="text-2-3-1">
<p>
此时双方会通过 P2P 接口地址进行交互。WPS具体使用的方式有PBC或者PIN
的方式。
</p>


<div class="figure">
<p><img src="/images/2016/2016031008.png" alt="2016031008.png" />
</p>
</div>

<p>
下面我们主要看下WPS的交互过程：
</p>
<ol class="org-ol">
<li><code>wpas_wps_add_network</code>
添加一个新的SSID， 设置其 <code>key_mgmt</code> 的值为 WPS， <code>eap</code> 值为WSC，
<code>identity</code>  为 <code>WSC_ID_ENROLLEE</code> 。
</li>
<li><code>wpa_config_set(ssid, "phase1", "\"pbc=1\"", 0)</code>
       设置网络参数： phase1的值。
</li>
<li>注册WPS协商超时处理函数
WPS超时时间为120秒。
</li>
<li><code>wpas_wps_reassoc</code>
       它会执行如下几个重要动作：
<ul class="org-ul">
<li>如果当前有连接到某个SSID，则断开。
</li>
<li>标记所有其他的网络为禁用状态，以触发重新关联动作。
</li>
<li>请求一次扫描， 专门扫描GO所在的频率。
会构建WPS IE携带上Probe Request中。
</li>
</ul>
</li>
<li>等待扫描结果
获得扫描结果后，会通过 <code>wpas_select_network_from_last_scan</code> 连
接GO对应的SSID。 向GO发送关联请求。
</li>
<li><code>wpa_supplicant_associate</code>
向Driver发送Association Request的命令。然后调用
<code>wpa_supplicant_rsn_supp_set_config</code> 通知 <code>wpa_sm</code> 状态机配置已
经发生更改。 最后调用 <code>wpa_supplicant_initiate_eapol</code> 初始化
<code>eapol_sm</code> 配置。
</li>
<li>收到到Associate Response信息， <code>wpa_supplicant_event_assoc</code>
成功关联上GO后，开始了WPS的交互过程。 GC首先发一笔：
<code>eapol_sm_txStart</code> 将 <code>IEEE802_1X_TYPE_EAPOL_START</code> 包发出去。
</li>
</ol>
</div>
</div>

<div id="outline-container-sec-2-3-2" class="outline-4">
<h4 id="sec-2-3-2">Registar</h4>
<div class="outline-text-4" id="text-2-3-2">
<p>
首先看下 <code>wpas_start_wps_go</code> 几个主要的过程：
</p>
<ol class="org-ol">
<li><code>wpas_copy_go_neg_results</code>
       复制协商后的参数信息。
</li>
<li><code>wpa_config_add_network</code> 
       添加一个网络SSID.
</li>
<li>配置新建的网络SSID的基本信息。
</li>
<li>设置wpa<sub>supplicant实例相关信息。</sub>
       设置回调接口： <code>p2p_go_configured</code>
</li>
<li><code>wpa_supplicant_req_scan</code>
       发起一次扫描。
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">SME</h3>
<div class="outline-text-3" id="text-2-4">
<p>
SME was designed to be used when the driver does provide the
separate authentication and association commands. 
</p>

<div class="org-src-container">

<pre class="src src-c">/* Driver provides separate commands for authentication and association (SME in
 * wpa_supplicant). */
#define WPA_DRIVER_FLAGS_SME            0x00000020
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">SoftAp</h3>
<div class="outline-text-3" id="text-2-5">
<p>
hostapd是一个用户空间程序，实现了AP和认证服务器的功能。通过配置文件
hostapd.conf 来修改一些Wifi参数。
</p>

<div class="org-src-container">
<label class="org-src-name">hostapd配置文件示例</label>
<pre class="src src-sh">interface=wlan0 
driver=nl80211 
ssid=woody_hostap
hw_mode=g 
channel=6 
ieee80211n=1
auth_algs=0
wpa=1 
wpa_passphrase=12345678
wpa_key_mgmt=WPA-PSK 
wpa_pairwise=TKIP
wpa_ptk_rekey=600
</pre>
</div>
</div>

<div id="outline-container-sec-2-5-1" class="outline-4">
<h4 id="sec-2-5-1">数据结构</h4>
<div class="outline-text-4" id="text-2-5-1">
<ol class="org-ol">
<li><code>struct hapd_interfaces</code>
<div class="org-src-container">

<pre class="src src-c">struct hapd_interfaces {
        int (*reload_config)(struct hostapd_iface *iface);
        struct hostapd_config * (*config_read_cb)(const char *config_fname);
        int (*ctrl_iface_init)(struct hostapd_data *hapd);
        void (*ctrl_iface_deinit)(struct hostapd_data *hapd);
        int (*for_each_interface)(struct hapd_interfaces *interfaces,
                                  int (*cb)(struct hostapd_iface *iface,
                                            void *ctx), void *ctx);
        int (*driver_init)(struct hostapd_iface *iface);

        size_t count;
        int global_ctrl_sock;
        struct wpa_ctrl_dst *global_ctrl_dst;
        char *global_iface_path;
        char *global_iface_name;
#ifndef CONFIG_NATIVE_WINDOWS
        gid_t ctrl_iface_group;
#endif /* CONFIG_NATIVE_WINDOWS */
        struct hostapd_iface **iface;

        size_t terminate_on_error;
#ifndef CONFIG_NO_VLAN
        struct dynamic_iface *vlan_priv;
#endif /* CONFIG_NO_VLAN */
};
</pre>
</div>
</li>
</ol>



<p>
WifiStateMachine: (Initial State)
CMD<sub>START</sub><sub>AP</sub> &#x2013;&gt;  setWifiApState
</p>

<p>
SoftApStartingState:
CMD<sub>TETHER</sub><sub>STATE</sub><sub>CHANGE</sub>
</p>

<div class="org-src-container">

<pre class="src src-sh">01-01 00:06:05.374 E/hostapd ( 1638): Configuration file: /data/misc/wifi/hostapd.conf
01-01 00:06:05.374 E/hostapd ( 1638): Configuration file: /data/misc/wifi/hostapd.conf
01-01 00:06:05.376 I/hostapd ( 1638): rfkill: Cannot open RFKILL control device
01-01 00:06:05.966 E/hostapd ( 1638): Using interface wlan0 with hwaddr 00:22:13:03:21:3c and ssid "AndroidAP"
01-01 00:06:06.271 I/hostapd ( 1638): wlan0: interface state UNINITIALIZED-&gt;ENABLED
01-01 00:06:06.271 I/hostapd ( 1638): wlan0: AP-ENABLED
</pre>
</div>

<p>
wifi.tethering.interface
</p>
</div>
</div>
</div>
</div>


<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><code>wpa_supplicant</code> 代码修改</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">add a conf parameter to start a GO as HT40 if allowed</h3>
<div class="outline-text-3" id="text-3-1">
<p>
When specified in the conf file this parameter will make all
invocations of p2p<sub>group</sub><sub>add</sub> and p2p<sub>connect</sub> behave as if "ht40"
has been specified on the command line.
This shouldn't do harm since regulatory constraints and driver
capabilities are consulted anyway before starting HT40 mode.
</p>

<div class="org-src-container">

<pre class="src src-sh">---
 wpa_supplicant/config.c      |    1 +
 wpa_supplicant/config.h      |   10 ++++++++++
 wpa_supplicant/config_file.c |    2 ++
 wpa_supplicant/ctrl_iface.c  |    4 ++--
 4 files changed, 15 insertions(+), 2 deletions(-)

diff --git a/wpa_supplicant/config.c b/wpa_supplicant/config.c
index be21029..3f64b03 100644
--- a/wpa_supplicant/config.c
+++ b/wpa_supplicant/config.c
@@ -3000,6 +3000,7 @@ static const struct global_parse_data global_fields[] = {
        { INT_RANGE(p2p_intra_bss, 0, 1), CFG_CHANGED_P2P_INTRA_BSS },
        { INT(p2p_group_idle), 0 },
        { FUNC(p2p_pref_chan), CFG_CHANGED_P2P_PREF_CHAN },
+       { INT(p2p_go_ht40), 0 },
 #endif /* CONFIG_P2P */
        { FUNC(country), CFG_CHANGED_COUNTRY },
        { INT(bss_max_count), 0 },
diff --git a/wpa_supplicant/config.h b/wpa_supplicant/config.h
index b889ab8..9cf5468 100644
--- a/wpa_supplicant/config.h
+++ b/wpa_supplicant/config.h
@@ -747,6 +747,16 @@ struct wpa_config {
         *     matching network block
         */
        int auto_interworking;
+
+       /**
+        * p2p_go_ht40 - Default mode for HT40 enable when operating as GO.
+        *
+        * This will take effect for p2p_group_add and p2p_connect. Note that
+        * regulatory constraints and driver capabilities are consulted anyway,
+        * so setting it to 1 can't do real harm
+        * By default: 0 (disabled)
+        */
+       int p2p_go_ht40;
 };


diff --git a/wpa_supplicant/config_file.c b/wpa_supplicant/config_file.c
index 531957a..bd9c17f 100644
--- a/wpa_supplicant/config_file.c
+++ b/wpa_supplicant/config_file.c
@@ -868,6 +868,8 @@ static void wpa_config_write_global(FILE *f, struct wpa_config *config)
                }
                fprintf(f, "\n");
        }
+       if (config-&gt;p2p_go_ht40)
+               fprintf(f, "p2p_go_ht40=%u\n", config-&gt;p2p_go_ht40);
 #endif /* CONFIG_P2P */
        if (config-&gt;country[0] &amp;&amp; config-&gt;country[1]) {
                fprintf(f, "country=%c%c\n",
diff --git a/wpa_supplicant/ctrl_iface.c b/wpa_supplicant/ctrl_iface.c
index ba2edff..c9c6826 100644
--- a/wpa_supplicant/ctrl_iface.c
+++ b/wpa_supplicant/ctrl_iface.c
@@ -3117,7 +3117,7 @@ static int p2p_ctrl_connect(struct wpa_supplicant *wpa_s, char *cmd,
        auth = os_strstr(pos, " auth") != NULL;
        automatic = os_strstr(pos, " auto") != NULL;
        pd = os_strstr(pos, " provdisc") != NULL;
-       ht40 = os_strstr(pos, " ht40") != NULL;
+       ht40 = (os_strstr(cmd, "ht40") != NULL) || wpa_s-&gt;conf-&gt;p2p_go_ht40;

        pos2 = os_strstr(pos, " go_intent=");
        if (pos2) {
@@ -3624,7 +3624,7 @@ static int p2p_ctrl_group_add(struct wpa_supplicant *wpa_s, char *cmd)
        if (pos)
                freq = atoi(pos + 5);

-       ht40 = os_strstr(cmd, "ht40") != NULL;
+       ht40 = (os_strstr(cmd, "ht40") != NULL) || wpa_s-&gt;conf-&gt;p2p_go_ht40;

        if (os_strncmp(cmd, "persistent=", 11) == 0)
                return p2p_ctrl_group_add_persistent(wpa_s, cmd + 11, freq,
--
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">add 165和169信道支持</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Channels 165 and 169 are part of operating class 125. Add support for these channels.
主要修改两个地方：
</p>
<ol class="org-ol">
<li><code>ieee802_11_common.c</code>
<div class="org-src-container">

<pre class="src src-c">static int ieee80211_chan_to_freq_global(u8 op_class, u8 chan)
{
        /* Table E-4 in IEEE Std 802.11-2012 - Global operating classes */
        switch (op_class) {
          ...
        case 125: /* channels 149,153,157,161,165,169 */
                if (chan &lt; 149 || chan &gt; 169)
                        return -1;
                return 5000 + 5 * chan;
        ...

        return -1;
}
</pre>
</div>
</li>

<li><code>p2p_supplicant.c</code>
<div class="org-src-container">

<pre class="src src-c">static const struct p2p_oper_class_map op_class[] = {
              ...
        { HOSTAPD_MODE_IEEE80211A, 125, 149, 169, 4, BW20 },
              ...
};
</pre>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">P2P: Clear the discovery state incase of deffered GO Neg response</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">

<pre class="src src-sh">diff --git a/src/p2p/p2p.c b/src/p2p/p2p.c
index 767706c..5d6abe3 100644
--- a/src/p2p/p2p.c
+++ b/src/p2p/p2p.c
@@ -3572,8 +3572,17 @@ static void p2p_go_neg_resp_failure_cb(struct p2p_data *p2p, int success,
                struct p2p_device *dev;
                dev = p2p_get_device(p2p, addr);
                if (dev &amp;&amp;
-                   dev-&gt;status == P2P_SC_FAIL_INFO_CURRENTLY_UNAVAILABLE)
+                   dev-&gt;status == P2P_SC_FAIL_INFO_CURRENTLY_UNAVAILABLE) {
                        dev-&gt;flags |= P2P_DEV_PEER_WAITING_RESPONSE;
+                       if ((p2p-&gt;state == P2P_SEARCH) ||
+                           (p2p-&gt;state == P2P_LISTEN_ONLY)) {
+                               /* Clear our search state or Listen state since
+                                * now peer is awaiting response from our side.
+                                */
+                               p2p_dbg(p2p, "Clear the P2P discovery state");
+                               p2p_stop_find(p2p);
+                       }
+               }
        }

        if (p2p-&gt;state == P2P_SEARCH || p2p-&gt;state == P2P_SD_DURING_FIND)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Android: P2P: Fix restriction of GO channels on A-band</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">

<pre class="src src-sh">diff --git a/src/p2p/p2p_go_neg.c b/src/p2p/p2p_go_neg.c
index 17fb329..bd583be 100644
--- a/src/p2p/p2p_go_neg.c
+++ b/src/p2p/p2p_go_neg.c
@@ -418,7 +418,13 @@ void p2p_reselect_channel(struct p2p_data *p2p,

        /* Prefer a 5 GHz channel */
        for (i = 0; i &lt; intersection-&gt;reg_classes; i++) {
+#ifdef ANDROID_P2P
+               struct p2p_reg_class prc;
+               struct p2p_reg_class *c = &amp;prc;
+               p2p_copy_reg_class(c, &amp;intersection-&gt;reg_class[i]);
+#else
                struct p2p_reg_class *c = &amp;intersection-&gt;reg_class[i];
+#endif
                if ((c-&gt;reg_class == 115 || c-&gt;reg_class == 124) &amp;&amp;
                    c-&gt;channels) {
                        unsigned int r;
diff --git a/src/p2p/p2p_i.h b/src/p2p/p2p_i.h
index d28aae9..81e521e 100644
--- a/src/p2p/p2p_i.h
+++ b/src/p2p/p2p_i.h
@@ -572,6 +572,9 @@ void p2p_channels_intersect(const struct p2p_channels *a,
                            struct p2p_channels *res);
 int p2p_channels_includes(const struct p2p_channels *channels, u8 reg_class,
                          u8 channel);
+#ifdef ANDROID_P2P
+size_t p2p_copy_reg_class(struct p2p_reg_class *dc, struct p2p_reg_class *sc);
+#endif

 /* p2p_parse.c */
 int p2p_parse_p2p_ie(const struct wpabuf *buf, struct p2p_message *msg);
diff --git a/src/p2p/p2p_utils.c b/src/p2p/p2p_utils.c
index 0769ede..a4c48f6 100644
--- a/src/p2p/p2p_utils.c
+++ b/src/p2p/p2p_utils.c
@@ -244,12 +244,37 @@ int p2p_channels_includes_freq(const struct p2p_channels *channels,
 }


+#ifdef ANDROID_P2P
+static int p2p_block_op_freq(unsigned int freq)
+{
+       return (freq &gt;= 5170 &amp;&amp; freq &lt; 5745);
+}
+
+
+size_t p2p_copy_reg_class(struct p2p_reg_class *dc, struct p2p_reg_class *sc)
+{
+       unsigned int i;
+
+       dc-&gt;reg_class = sc-&gt;reg_class;
+       dc-&gt;channels = 0;
+       for (i=0; i &lt; sc-&gt;channels; i++) {
+               if (!p2p_block_op_freq(p2p_channel_to_freq(sc-&gt;reg_class,
+                                                          sc-&gt;channel[i]))) {
+                       dc-&gt;channel[dc-&gt;channels] = sc-&gt;channel[i];
+                       dc-&gt;channels++;
+               }
+       }
+       return dc-&gt;channels;
+}
+#endif
+
+
 int p2p_supported_freq(struct p2p_data *p2p, unsigned int freq)
 {
        u8 op_reg_class, op_channel;

 #ifdef ANDROID_P2P
-       if (freq &gt;= 5170 &amp;&amp; freq &lt; 5745)
+       if (p2p_block_op_freq(freq))
                return 0;
 #endif
        if (p2p_freq_to_channel(freq, &amp;op_reg_class, &amp;op_channel) &lt; 0)
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">常用代码片断</h2>
<div class="outline-text-2" id="text-4">
<p>
记录 <code>wpa_supplicant</code> 源码中常见的一些代码片断。
</p>
</div>

<div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">遍历当前的接口</h3>
<div class="outline-text-3" id="text-4-1">
<div class="org-src-container">

<pre class="src src-c">struct wpa_global *global = wpa_s-&gt;global;

for (wpa_s = global-&gt;ifaces; wpa_s; wpa_s = wpa_s-&gt;next) {
  if (os_strcmp(wpa_s-&gt;ifname, "p2p") == 0) {
    break;
  }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">遍历接口上存在的SSID</h3>
<div class="outline-text-3" id="text-4-2">
<div class="org-src-container">

<pre class="src src-c">struct wpa_ssid *s;

for (s = wpa_s-&gt;conf-&gt;ssid; s; s = s-&gt;next) {
  if (s-&gt;mode == WPAS_MODE_P2P_GO) {
    ...
  }
 }
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">遍历当前的接口(方法2)</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">

<pre class="src src-c">/*
 * Check other interfaces to see if they share the same radio. If
 * so, they get updated with this same scan info.
 */
struct wpa_supplicant *ifs, wpa_s;
...
dl_list_for_each(ifs, &amp;wpa_s-&gt;radio-&gt;ifaces, struct wpa_supplicant,
                 radio_list) {
  if (ifs != wpa_s) {
    wpa_printf(MSG_DEBUG, "%s: Updating scan results from "
               "sibling", ifs-&gt;ifname);
    ...
  }
}
</pre>
</div>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">遍历hostapd上的bss</h3>
<div class="outline-text-3" id="text-4-4">
<div class="org-src-container">

<pre class="src src-c">for (i = 0; i &lt; hapd-&gt;iface-&gt;num_bss; i++) {
                struct hostapd_data *bss = hapd-&gt;iface-&gt;bss[i];
                if (bss-&gt;conf-&gt;bridge[0])
                        params.bridge[i] = bss-&gt;conf-&gt;bridge;
        }
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
<a href="https://w1.fi/wpa_supplicant/devel/index.html">https://w1.fi/wpa_supplicant/devel/index.html</a>
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
<a href="http://lists.shmoo.com/pipermail/hostap/">http://lists.shmoo.com/pipermail/hostap/</a>
</p></div>


</div>
</div></div>
